<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[tomchen&fleur.wang's moving castle]]></title>
  <subtitle><![CDATA[This dog is lazy, left nothing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.ct2wj.com/"/>
  <updated>2015-12-31T14:37:16.000Z</updated>
  <id>http://www.ct2wj.com/</id>
  
  <author>
    <name><![CDATA[tomchen]]></name>
    <email><![CDATA[tomchenv5@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[android compile tasks中dex过程源码情景分析]]></title>
    <link href="http://www.ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/"/>
    <id>http://www.ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/</id>
    <published>2015-12-31T09:40:37.000Z</published>
    <updated>2015-12-31T14:37:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr>
<p><a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>中我们知道main dex的class可以由maindexlist.txt指定，<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/" target="_blank" rel="external">Android MultiDex机制杂谈</a>中我们分析了google MultiDex机制中Secondary dex的install过程，那么，我们的app在android gradle build过程中，.dex文件是怎么创建的呢？ 再者，Secondary dex中的class是按什么顺序分配到不同dex中的呢？<br><a id="more"></a></p>
<h1 id="0x01_android_build_system_u6982_u8FF0"><a href="#0x01_android_build_system_u6982_u8FF0" class="headerlink" title="0x01 android build system概述"></a>0x01 android build system概述</h1><hr>
<p>为了解答上面的两个问题，本文将进一步分析android build system源码。</p>
<p><a href="http://developer.android.com/intl/zh-cn/sdk/installing/studio-build.html" target="_blank" rel="external">android build system</a>是google提供的一组用来构建、运行、测试和打包我们app的工具集，包含了<code>aapt</code>、<code>aidl</code>、<code>javac</code>、<code>dex</code>、<code>apkbuilder</code>、<code>Jarsigner</code>、<code>zipalign</code>等工具。在我们构建app时，build进程会去按一定顺序调用上述工具来生成相应文件，而最终的输出将会是一个完整的可安装的.apk文件，构建流程如下：</p>
<p><img src="http://developer.android.com/images/build.png" alt=""></p>
<p>构建系统先从product flavors, build types和dependencies中合并资源，如果不同目录下有重名资源，将按以下优先级进行覆盖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &gt; build types &gt; product flavors &gt; main <span class="keyword">source</span> directory</span><br></pre></td></tr></table></figure>
<ol>
<li>aapt编译应用的资源文件（如AndroidManifest.xml），输出R.java文件</li>
<li>aidl把.aidl文件转换为对应的java interface文件</li>
<li>javac编译所有.java文件，输出.class文件</li>
<li>dex工具把上面生成的.class文件转换为.dex文件</li>
<li>apkbuilder把所有没编译的资源（如图片），编译过的资源和dex文件打包输出为.apk文件</li>
<li>在release模式下，用zipalign工具对.apk进行对齐处理，以减少运行时内存占用</li>
</ol>
<p>本文重点对<code>第4步</code>中.class经过dex到.dex过程源码进行分析。</p>
<h1 id="0x02_android_compile_tasks_u5206_u6790"><a href="#0x02_android_compile_tasks_u5206_u6790" class="headerlink" title="0x02 android compile tasks分析"></a>0x02 android compile tasks分析</h1><hr>
<p>为了更好地分析.dex的产生过程，本文设定情景如下：</p>
<blockquote>
<p>构建工具为gradle，采用android plugin <code>&#39;com.android.application&#39;</code>，method数超过65535，需要进行multidex，并且指定了<code>multiDexEnabled = true</code>。</p>
</blockquote>
<p>在shell终端cd到project根目录，输入： </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gradle</span> assemble</span><br></pre></td></tr></table></figure>
<p>gradle进程会启动，在dex之前，进程控制流将进入VariantManager. createTasksForVariantData。添加完对assemble task的依赖后，会去调用taskManager.createTasksForVariantData(tasks, variantData)。由于场景的android plugin为’com.android.application’，这里的taskManager的类型是ApplicationTaskManager。</p>
<p>com/android/build/gradle/internal/VariantManager.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create tasks for the specified variantData.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span><br><span class="line">        <span class="keyword">final</span> TaskFactory tasks,</span><br><span class="line">        <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add dependency of assemble task on assemble build type task.</span></span><br><span class="line">    tasks.named(<span class="string">"assemble"</span>, <span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            BuildTypeData buildTypeData = buildTypes.get(</span><br><span class="line">                            variantData.getVariantConfiguration().getBuildType().getName());</span><br><span class="line">            task.dependsOn(buildTypeData.getAssembleTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">        taskManager.createTasksForVariantData(tasks, variantData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationTaskManager.createTasksForVariantData()会通过ThreadRecorder.get().record()提交类型为Recorder.Block<void>匿名内部类作为callback，在call回调中调用父类TaskManager.createPostCompilationTasks。ThreadRecorder可以记录该任务的在当前线程的执行时间，并且保证task之间是串行执行的。</void></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * TaskManager for creating tasks in an Android application project.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTaskManager</span> <span class="keyword">extends</span> <span class="title">TaskManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span><br><span class="line">            @NonNull <span class="keyword">final</span> TaskFactory tasks,</span><br><span class="line">            @NonNull <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// Add a compile task</span></span><br><span class="line">        ThreadRecorder.get().record(ExecutionType.APP_TASK_MANAGER_CREATE_COMPILE_TASK,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        AndroidTask&lt;JavaCompile&gt; javacTask = createJavacTask(tasks, variantScope);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (variantData.getVariantConfiguration().getUseJack()) &#123;</span><br><span class="line">                            createJackTask(tasks, variantScope);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            setJavaCompilerTask(javacTask, tasks, variantScope);</span><br><span class="line">                            createJarTask(tasks, variantScope);</span><br><span class="line">                            createPostCompilationTasks(tasks, variantScope);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskManager.createPostCompilationTasks方法，这个方法比较长，我们分段来分析。</p>
<p>首先根据build.gralde得到isMultiDexEnabled，isMultiDexEnabled，isLegacyMultiDexMode，由于前面已经假设当前为需要MultiDex的场景，因此isMultiDexEnabled为true。若isMinifyEnabled也为true，则说明输入jar包需要进行混淆，本场景先不考虑。</p>
<p>TaskManager.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates the post-compilation tasks for the given Variant.</span><br><span class="line"> *</span><br><span class="line"> * These tasks create the dex file from the .class files, plus optional intermediary steps like</span><br><span class="line"> * proguard and jacoco</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPostCompilationTasks</span><span class="params">(TaskFactory tasks, @NonNull <span class="keyword">final</span> VariantScope variantScope)</span> </span>&#123;</span><br><span class="line">    checkNotNull(variantScope.getJavacTask());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();</span><br><span class="line">    <span class="keyword">final</span> GradleVariantConfiguration config = variantData.getVariantConfiguration();</span><br><span class="line"></span><br><span class="line">    TransformManager transformManager = variantScope.getTransformManager();</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">boolean</span> isMinifyEnabled = config.isMinifyEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> isMultiDexEnabled = config.isMultiDexEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> isLegacyMultiDexMode = config.isLegacyMultiDexMode();</span><br><span class="line"></span><br><span class="line">    AndroidConfig extension = variantScope.getGlobalScope().getExtension();</span><br></pre></td></tr></table></figure>
<p>在支持MultiDex的场景中，先创建manifestKeepListTask，将依赖设置为ManifestProcessorTask，这些android compile task由AndroidTask\<transformtask>类型来描述。</transformtask></p>
<p>接着创建multiDexClassListTask，依赖manifestKeepListTask。这两个tasks用来输出maindexlist.txt，其中包含了MainDex中必须的class，可参见<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ----- Multi-Dex support</span></span><br><span class="line"></span><br><span class="line">AndroidTask&lt;TransformTask&gt; multiDexClassListTask = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// non Library test are running as native multi-dex</span></span><br><span class="line"><span class="keyword">if</span> (isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (AndroidGradleOptions.useNewShrinker(project)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"New shrinker + multidex not supported yet."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="comment">// create a transform to jar the inputs into a single jar.</span></span><br><span class="line">    <span class="keyword">if</span> (!isMinifyEnabled) &#123;</span><br><span class="line">        <span class="comment">// merge the classes only, no need to package the resources since they are</span></span><br><span class="line">        <span class="comment">// not used during the computation.</span></span><br><span class="line">        JarMergingTransform jarMergingTransform = <span class="keyword">new</span> JarMergingTransform(</span><br><span class="line">                TransformManager.SCOPE_FULL_PROJECT);</span><br><span class="line">        transformManager.addTransform(tasks, variantScope, jarMergingTransform);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="comment">// Create a task to collect the list of manifest entry points which are</span></span><br><span class="line">    <span class="comment">// needed in the primary dex</span></span><br><span class="line">    AndroidTask&lt;CreateManifestKeepList&gt; manifestKeepListTask = androidTasks.create(tasks,</span><br><span class="line">            <span class="keyword">new</span> CreateManifestKeepList.ConfigAction(variantScope));</span><br><span class="line">    manifestKeepListTask.dependsOn(tasks,</span><br><span class="line">            variantData.getOutputs().get(<span class="number">0</span>).getScope().getManifestProcessorTask());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="comment">// create the transform that's going to take the code and the proguard keep list</span></span><br><span class="line">    <span class="comment">// from above and compute the main class list.</span></span><br><span class="line">    MultiDexTransform multiDexTransform = <span class="keyword">new</span> MultiDexTransform(</span><br><span class="line">            variantScope.getManifestKeepListFile(),</span><br><span class="line">            variantScope,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">    multiDexClassListTask = transformManager.addTransform(</span><br><span class="line">            tasks, variantScope, multiDexTransform);</span><br><span class="line">    multiDexClassListTask.dependsOn(tasks, manifestKeepListTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后创建dexTask，这个用来把.class文件转为.dex的task，它依赖multiDexClassListTask。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// create dex transform</span></span><br><span class="line">    DexTransform dexTransform = <span class="keyword">new</span> DexTransform(</span><br><span class="line">            extension.getDexOptions(),</span><br><span class="line">            config.getBuildType().isDebuggable(),</span><br><span class="line">            isMultiDexEnabled,</span><br><span class="line">            isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode ? variantScope.getMainDexListFile() : <span class="keyword">null</span>,</span><br><span class="line">            variantScope.getPreDexOutputDir(),</span><br><span class="line">            variantScope.getGlobalScope().getAndroidBuilder(),</span><br><span class="line">            getLogger());</span><br><span class="line">    AndroidTask&lt;TransformTask&gt; dexTask = transformManager.addTransform(</span><br><span class="line">            tasks, variantScope, dexTransform);</span><br><span class="line">    <span class="comment">// need to manually make dex task depend on MultiDexTransform since there's no stream</span></span><br><span class="line">    <span class="comment">// consumption making this automatic</span></span><br><span class="line">    dexTask.optionalDependsOn(tasks, multiDexClassListTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task执行时，gradle引擎会去调用含有@TaskAction注解的方法，TransformTask类拥有Transfrom类型字段，其transform方法被标记为@TaskAction。接着同样通过ThreadRecorder.get().record中回调call()，执行transform.transform()</p>
<p>TransformTask.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A task running a transform.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ParallelizableTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTask</span> <span class="keyword">extends</span> <span class="title">StreamBasedTask</span> <span class="keyword">implements</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform transform;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">final</span> IncrementalTaskInputs incrementalTaskInputs)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line">		 ...</span><br><span class="line">        ThreadRecorder.get().record(ExecutionType.TASK_TRANSFORM,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        transform.transform(</span><br><span class="line">                                TransformTask.<span class="keyword">this</span>,</span><br><span class="line">                                consumedInputs.getValue(),</span><br><span class="line">                                referencedInputs.getValue(),</span><br><span class="line">                                outputStream != <span class="keyword">null</span> ? outputStream.asOutput() : <span class="keyword">null</span>,</span><br><span class="line">                                isIncremental.getValue());</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"project"</span>, getProject().getName()),</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"transform"</span>, transform.getName()),</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"incremental"</span>, Boolean.toString(transform.isIncremental())));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述android compile tasks关系可以用下图描述：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/multi-dex-task.jpg" alt=""></p>
<p>从gradle task角度上看，这些task都属于TransformTask（继承至DefaultTask），它们区别仅在于transform字段。DexTask是本文主要关心的task，下面分析这个task执行过程中都做了什么。</p>
<h1 id="0x03_DexTask_u6267_u884C_u8FC7_u7A0B_u5206_u6790"><a href="#0x03_DexTask_u6267_u884C_u8FC7_u7A0B_u5206_u6790" class="headerlink" title="0x03 DexTask执行过程分析"></a>0x03 DexTask执行过程分析</h1><hr>
<p>android build system中dex过程发生在DexTask，DexTask关联的Transform是DexTransform。</p>
<p>当DexTransform.transfrom方法被调用时，会先创建并初始化main目录作为输出dex的目录，然后调用androidBuilder.convertByteCode方法进行.class到.dex的转换，此时jarInputs为classes.jar，directoryInputs长度为空，传递的boolean类型的multiDex参数来自build.gralde文件中在<code>defaultConfig</code>对<code>multiDexEnabled = true</code>的设置。</p>
<p>DexTransform.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(</span><br><span class="line">        @NonNull Context context,</span><br><span class="line">        @NonNull Collection&lt;TransformInput&gt; inputs,</span><br><span class="line">        @NonNull Collection&lt;TransformInput&gt; referencedInputs,</span><br><span class="line">        @Nullable TransformOutputProvider outputProvider,</span><br><span class="line">        <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> TransformException, IOException, InterruptedException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// Gather a full list of all inputs.</span></span><br><span class="line">    List&lt;JarInput&gt; jarInputs = Lists.newArrayList();</span><br><span class="line">    List&lt;DirectoryInput&gt; directoryInputs = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (TransformInput input : inputs) &#123;</span><br><span class="line">        jarInputs.addAll(input.getJarInputs());</span><br><span class="line">        directoryInputs.addAll(input.getDirectoryInputs());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// if only one scope or no per-scope dexing, just do a single pass that</span></span><br><span class="line">        <span class="comment">// runs dx on everything.</span></span><br><span class="line">        <span class="keyword">if</span> ((jarInputs.size() + directoryInputs.size()) == <span class="number">1</span> || !dexOptions.getPreDexLibraries()) &#123;</span><br><span class="line">            File outputDir = outputProvider.getContentLocation(<span class="string">"main"</span>,</span><br><span class="line">                    getOutputTypes(), getScopes(),</span><br><span class="line">                    Format.DIRECTORY);</span><br><span class="line">            FileUtils.mkdirs(outputDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first delete the output folder where the final dex file(s) will be.</span></span><br><span class="line">            FileUtils.emptyFolder(outputDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gather the inputs. This mode is always non incremental, so just</span></span><br><span class="line">            <span class="comment">// gather the top level folders/jars</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;File&gt; inputFiles = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (JarInput jarInput : jarInputs) &#123;</span><br><span class="line">                inputFiles.add(jarInput.getFile());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DirectoryInput directoryInput : directoryInputs) &#123;</span><br><span class="line">                inputFiles.add(directoryInput.getFile());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            androidBuilder.convertByteCode(</span><br><span class="line">                    inputFiles,</span><br><span class="line">                    outputDir,</span><br><span class="line">                    multiDex,</span><br><span class="line">                    mainDexListFile,</span><br><span class="line">                    dexOptions,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">true</span>,</span><br><span class="line">                    <span class="keyword">new</span> LoggedProcessOutputHandler(logger));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>为了把输入的.class转换为.dex，AndroidBuilder.convertByteCode会另起进程去做dex，实际上是在新进程中exec dex工具，接下来我们进入dex源码，看看到底发生了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertByteCode</span><span class="params">(</span><br><span class="line">         @NonNull Collection&lt;File&gt; inputs,</span><br><span class="line">         @NonNull File outDexFolder,</span><br><span class="line">                  <span class="keyword">boolean</span> multidex,</span><br><span class="line">         @Nullable File mainDexList,</span><br><span class="line">         @NonNull DexOptions dexOptions,</span><br><span class="line">         @Nullable List&lt;String&gt; additionalParameters,</span><br><span class="line">         <span class="keyword">boolean</span> incremental,</span><br><span class="line">         <span class="keyword">boolean</span> optimize,</span><br><span class="line">         @NonNull ProcessOutputHandler processOutputHandler)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, InterruptedException, ProcessException </span>&#123;</span><br><span class="line">...</span><br><span class="line">     BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">     DexProcessBuilder builder = <span class="keyword">new</span> DexProcessBuilder(outDexFolder);</span><br><span class="line"></span><br><span class="line">     builder.setVerbose(mVerboseExec)</span><br><span class="line">             .setIncremental(incremental)</span><br><span class="line">             .setNoOptimize(!optimize)</span><br><span class="line">             .setMultiDex(multidex)</span><br><span class="line">             .setMainDexList(mainDexList)</span><br><span class="line">             .addInputs(verifiedInputs.build());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (additionalParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">         builder.additionalParameters(additionalParameters);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     JavaProcessInfo javaProcessInfo = builder.build(buildToolInfo, dexOptions);</span><br><span class="line"></span><br><span class="line">     ProcessResult result = mJavaProcessExecutor.execute(javaProcessInfo, processOutputHandler);</span><br><span class="line">     result.rethrowFailure().assertNormalExitValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04_dex_u8FC7_u7A0B_u5206_u6790"><a href="#0x04_dex_u8FC7_u7A0B_u5206_u6790" class="headerlink" title="0x04 dex过程分析"></a>0x04 dex过程分析</h1><hr>
<p>android 5.0中dex工具源码路径是dalvik/dx/src/com/android/dx，入口类是com.android.dx.command.Main，当解析到参数–dex时，转入com.android.dx.command.dexer.Main.main()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">             <span class="keyword">if</span> (arg.equals(<span class="string">"--dex"</span>)) &#123;</span><br><span class="line">                 com.android.dx.command.dexer.Main.main(without(args, i));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">"--dump"</span>)) &#123;</span><br><span class="line">                 com.android.dx.command.dump.Main.main(without(args, i));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>main会调用com.android.dx.command.dexer.Main.run()，此时args.multiDex为true，直接进入runMultiDex</p>
<p>com.android.dx.command.dexer.Main.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(Arguments arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.multiDex) &#123;</span><br><span class="line">            <span class="keyword">return</span> runMultiDex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> runMonoDex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeOutput(humanOutRaw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runMultiDex会调用processAllFiles，第一行代码调用createDexFile()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processAllFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     createDexFile();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>createDexFile先检查outputDex(: DexFile)字段是否为空，不为空则调用writeDex()把该dex的byte[]添加到dexOutputArrays(: List\<byte[]>)。</byte[]></p>
<p>writeDex()具体是通过outputDex.toDex(humanOutWriter, args.verboseDump)得到dex的byte[]。java中数组的下标是int类型，长度为32bits，因此一个dex文件最大理论是4G，但实际由于method, field数等限制，正常最大也就10M左右。</p>
<p>然后还会为outputDex字段新建一个DexFile对象，表示当前dex文件已经处理完毕，可以开始处理新的dex文件了。这里假设进程第一次执行createDexFile，因此outputDex为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDexFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputDex != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dexOutputArrays.add(writeDex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputDex = <span class="keyword">new</span> DexFile(args.dexOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.dumpWidth != <span class="number">0</span>) &#123;</span><br><span class="line">        outputDex.setDumpWidth(args.dumpWidth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后processAllFiles会根据args中numThreads来决定是否需要创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.numThreads &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    threadPool = Executors.newFixedThreadPool(args.numThreads);</span><br><span class="line">    parallelProcessorFutures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Void&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来判断args.mainDexListFile，不为空说明指定了maindexlist.txt文件，这里假设不为空，filesNames数组是{‘path/way/to/classes.jar’}，长度为1。方法在for循环中调用processOne()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   anyFilesProcessed = <span class="keyword">false</span>;</span><br><span class="line">   String[] fileNames = args.fileNames;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (args.mainDexListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// with --main-dex-list</span></span><br><span class="line">           FileNameFilter mainPassFilter = args.strictNameCheck ? <span class="keyword">new</span> MainDexListFilter() :</span><br><span class="line">               <span class="keyword">new</span> BestEffortMainDexListFilter();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// forced in main dex</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">               processOne(fileNames[i], mainPassFilter);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>processOne调用ClassPathOpener.process处理输入的classes.jar。ClassPathOpener会遍历classes.jar中的每个ZipEntry，读出byte[]，对每个ZipEntry在回调processFileBytes中调用Main.processFileBytes方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Processes one pathname element.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> pathname &#123;<span class="doctag">@code</span> non-null;&#125; the pathname to process. May</span><br><span class="line"> * be the path of a class file, a jar file, or a directory</span><br><span class="line"> * containing class files.</span><br><span class="line"> * <span class="doctag">@param</span> filter &#123;<span class="doctag">@code</span> non-null;&#125; A filter for excluding files.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processOne</span><span class="params">(String pathname, FileNameFilter filter)</span> </span>&#123;</span><br><span class="line">    ClassPathOpener opener;</span><br><span class="line"></span><br><span class="line">    opener = <span class="keyword">new</span> ClassPathOpener(pathname, <span class="keyword">false</span>, filter,</span><br><span class="line">            <span class="keyword">new</span> ClassPathOpener.Consumer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Main.processFileBytes(name, lastModified, bytes);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.numThreads &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        parallelProcessorFutures.add(threadPool.submit(<span class="keyword">new</span> ParallelProcessor(opener)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (opener.process()) &#123;</span><br><span class="line">            anyFilesProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.processFileBytes把输入的bytes分为三类：</p>
<ul>
<li>.class文件</li>
<li>.dex文件</li>
<li>资源文件</li>
</ul>
<p>如果输入是.dex或资源文件，则把bytes分别写入libraryDexBuffers字段或outputResources字段，此时输入name(: String)为.class。当发现是class，则进一步调用processClass处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * Processes one file, which may be either a class or a resource.</span><br><span class="line">  *</span><br><span class="line">  * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file</span><br><span class="line">  * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">  * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> isClass = name.endsWith(<span class="string">".class"</span>);</span><br><span class="line">     <span class="keyword">boolean</span> isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME);</span><br><span class="line">     <span class="keyword">boolean</span> keepResources = (outputResources != <span class="keyword">null</span>);</span><br><span class="line">... </span><br><span class="line">     String fixedName = fixPath(name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (isClass) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (keepResources &amp;&amp; args.keepClassesInJar) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (outputResources) &#123;</span><br><span class="line">                 outputResources.put(fixedName, bytes);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (lastModified &lt; minimumFileAge) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> processClass(fixedName, bytes);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClassesDex) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (libraryDexBuffers) &#123;</span><br><span class="line">             libraryDexBuffers.add(bytes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (outputResources) &#123;</span><br><span class="line">             outputResources.put(fixedName, bytes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>processClass方法主要做了以下几件事：</p>
<ol>
<li>为传入的class创建DirectClassFile对象，对应.class字节码文件</li>
<li>得到已经生成的dex的numMethodIds，numFieldIds</li>
<li>得到新Class的constantPoolSize，计算maxMethodIdsInDex = numMethodIds + constantPoolSize + 新Class的方法数 + 2个预留method， 计算maxFieldIdsInDex = numFieldIds + constantPoolSize + 新Class的字段数 + 9个预留field</li>
<li>一旦发现maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex 或者 maxFieldIdsInDex &gt; args.maxNumber OfIdxPerDex，说明当前dex已经满了，调用createDexFile创建新dex来容纳该Class</li>
<li>否则，通过CfTranslator.translate方法将输入的DirectClassFile对象，得到ClassDefItem，添加到outputDex(: DexFile)</li>
</ol>
<p>由此可以看出：</p>
<blockquote>
<p>secondray dex中的class是根据classes.jar中ZipEntry的遍历顺序添加的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * Processes one classfile.</span><br><span class="line">  *</span><br><span class="line">  * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file, clipped such that it</span><br><span class="line">  * &lt;i&gt;should&lt;/i&gt; correspond to the name of the class it contains</span><br><span class="line">  * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">  * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processClass</span><span class="params">(String name, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (! args.coreLibrary) &#123;</span><br><span class="line">         checkClassName(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     DirectClassFile cf =</span><br><span class="line">         <span class="keyword">new</span> DirectClassFile(bytes, name, args.cfOptions.strictNameCheck);</span><br><span class="line"></span><br><span class="line">     cf.setAttributeFactory(StdAttributeFactory.THE_ONE);</span><br><span class="line">     cf.getMagic();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> numMethodIds = outputDex.getMethodIds().items().size();</span><br><span class="line">     <span class="keyword">int</span> numFieldIds = outputDex.getFieldIds().items().size();</span><br><span class="line">     <span class="keyword">int</span> constantPoolSize = cf.getConstantPool().size();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> maxMethodIdsInDex = numMethodIds + constantPoolSize + cf.getMethods().size() +</span><br><span class="line">             MAX_METHOD_ADDED_DURING_DEX_CREATION;</span><br><span class="line">     <span class="keyword">int</span> maxFieldIdsInDex = numFieldIds + constantPoolSize + cf.getFields().size() +</span><br><span class="line">             MAX_FIELD_ADDED_DURING_DEX_CREATION;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (args.multiDex</span><br><span class="line">         <span class="comment">// Never switch to the next dex if current dex is already empty</span></span><br><span class="line">         &amp;&amp; (outputDex.getClassDefs().items().size() &gt; <span class="number">0</span>)</span><br><span class="line">         &amp;&amp; ((maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex) ||</span><br><span class="line">             (maxFieldIdsInDex &gt; args.maxNumberOfIdxPerDex))) &#123;</span><br><span class="line">         DexFile completeDex = outputDex;</span><br><span class="line">         createDexFile();</span><br><span class="line">         <span class="keyword">assert</span>  (completeDex.getMethodIds().items().size() &lt;= numMethodIds +</span><br><span class="line">                 MAX_METHOD_ADDED_DURING_DEX_CREATION) &amp;&amp;</span><br><span class="line">                 (completeDex.getFieldIds().items().size() &lt;= numFieldIds +</span><br><span class="line">                 MAX_FIELD_ADDED_DURING_DEX_CREATION);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ClassDefItem clazz =</span><br><span class="line">             CfTranslator.translate(cf, bytes, args.cfOptions, args.dexOptions, outputDex);</span><br><span class="line">         <span class="keyword">synchronized</span> (outputDex) &#123;</span><br><span class="line">             outputDex.add(clazz);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (ParseException ex) &#123;</span><br><span class="line">         DxConsole.err.println(<span class="string">"\ntrouble processing:"</span>);</span><br><span class="line">         <span class="keyword">if</span> (args.debug) &#123;</span><br><span class="line">             ex.printStackTrace(DxConsole.err);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ex.printContext(DxConsole.err);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     errors.incrementAndGet();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>再回到processAllFiles，前面假设指定了maindexlist，如果minialMainDex也为true的话，会立即创建新的DexFile，保证这个main dex中只包含maindexlist里的类，如何指定可以参考<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道 0x05</a>。前面没有过滤掉的class都会放入到secondary dex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexOutputArrays.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">"Too many classes in "</span> + Arguments.MAIN_DEX_LIST_OPTION</span><br><span class="line">                    + <span class="string">", main dex capacity exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.minimalMainDex) &#123;</span><br><span class="line">            <span class="comment">// start second pass directly in a secondary dex file.</span></span><br><span class="line">            createDexFile();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remaining files</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">            processOne(fileNames[i], <span class="keyword">new</span> NotFilter(mainPassFilter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// without --main-dex-list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">            processOne(fileNames[i], ClassPathOpener.acceptAll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (StopProcessing ex) &#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Ignore it and just let the error reporting do</span><br><span class="line">     * their things.</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在runMultiDex的最后，dex文件将以classes(..N).dex的形式输出在由args.outName指定的目录之下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runMultiDex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.outName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File outDir = <span class="keyword">new</span> File(args.outName);</span><br><span class="line">            <span class="keyword">assert</span> outDir.isDirectory();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dexOutputArrays.size(); i++) &#123;</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(outDir, getDexFileName(i)));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.write(dexOutputArrays.get(i));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    closeOutput(out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x05__u7ED3_u8BBA"><a href="#0x05__u7ED3_u8BBA" class="headerlink" title="0x05 结论"></a>0x05 结论</h1><hr>
<p>通过对android build system中android plugin tasks和dx工具源码的分析，我们可以得出如下结论：</p>
<ul>
<li><p>.dex文件本质上是.class文件经过com.android.dx.dex.file.DexFile.toDex方法转换得到</p>
</li>
<li><p>Secondary dex是在指定了<code>multiDexEnabled = true且MainDex满足65535限制</code>，或者<code>指定multiDexEnabled = true和minimalMainDex = true</code>的情况下，才会创建的dex，其包含的class是根据classes.jar中ZipEntry的遍历顺序添加的。</p>
</li>
</ul>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/" target="_blank" rel="external">http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr>
<p><a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/">MultiDex中出现的main dex capacity exceeded解决之道</a>中我们知道main dex的class可以由maindexlist.txt指定，<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/">Android MultiDex机制杂谈</a>中我们分析了google MultiDex机制中Secondary dex的install过程，那么，我们的app在android gradle build过程中，.dex文件是怎么创建的呢？ 再者，Secondary dex中的class是按什么顺序分配到不同dex中的呢？<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="android compile tasks" scheme="http://www.ct2wj.com/tags/android-compile-tasks/"/>
    
      <category term="build system" scheme="http://www.ct2wj.com/tags/build-system/"/>
    
      <category term="dex" scheme="http://www.ct2wj.com/tags/dex/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android MultiDex机制杂谈]]></title>
    <link href="http://www.ct2wj.com/2015/12/24/android-multidex-source-code-analysis/"/>
    <id>http://www.ct2wj.com/2015/12/24/android-multidex-source-code-analysis/</id>
    <published>2015-12-24T03:53:13.000Z</published>
    <updated>2015-12-31T14:25:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u4E3A_u4EC0_u4E48_u9700_u8981MutliDex"><a href="#0x00__u4E3A_u4EC0_u4E48_u9700_u8981MutliDex" class="headerlink" title="0x00 为什么需要MutliDex"></a>0x00 为什么需要MutliDex</h1><hr>
<p>如果你是一名android开发者，随着app功能复杂度的增加，代码量的增多和库的引入，你迟早会在5.0以下的某款设备上遇到：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conversion <span class="keyword">to</span> Dalvik format failed:</span><br><span class="line">Unable <span class="keyword">to</span> execute dex: <span class="function"><span class="keyword">method</span> <span class="title">ID</span> <span class="title">not</span> <span class="title">in</span> [0, 0<span class="title">xffff</span>]:</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trouble writing outpu<span class="variable">t:</span></span><br><span class="line">Too many field reference<span class="variable">s:</span> <span class="number">131000</span>; <span class="built_in">max</span> <span class="keyword">is</span> <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这说明你的app的方法数已经超过<code>65535</code>，如果打算继续兼容5.0以下手机，你可以采用google提供的<a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html" target="_blank" rel="external">MultiDex方案</a>，但5.0以下系统方法数为什么不能超过65535呢？<br><a id="more"></a></p>
<p>Dalvik的<a href="http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">invoke-kind指令集</a>，method reference index只留了16bits，最多能调用65535个方法</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke-kind <span class="comment">&#123;vC, vD, vE, vF, vG&#125;</span>, meth@BBBB</span><br><span class="line"></span><br><span class="line">B: <span class="function"><span class="keyword">method</span> <span class="title">reference</span> <span class="title">index</span> <span class="params">(16 bits)</span></span></span><br></pre></td></tr></table></figure>
<p>因此在生成dex文件的过程中，当方法数超过65535就会报错。</p>
<p>dalvik/dx/src/com/android/dx/merge/IndexMap.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maps the index offsets from one dex file to those in another. For example, if</span><br><span class="line"> * you have string #5 in the old dex file, its position in the new dex file is</span><br><span class="line"> * &#123;<span class="doctag">@code</span> strings[5]&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dex target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[] stringIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] typeIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] protoIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] fieldIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] methodIds;</span><br></pre></td></tr></table></figure>
<p>不仅methodIds用的是short数组类型，typeIds，protoIds，fieldIds也是short，都不能超过65535。也就是说，google dalvik开发者在这上面挖了个大坑，MultiDex就是来填这个坑的。</p>
<h1 id="0x01__u4F7F_u7528MultiDex"><a href="#0x01__u4F7F_u7528MultiDex" class="headerlink" title="0x01 使用MultiDex"></a>0x01 使用MultiDex</h1><hr>
<p>MultiDex在google官方提供的support包里面，在build.gradle中加上依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.android.support:multidex:1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>接着让app的Application继承MultiDexApplication</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDexApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiDexApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也别忘了在build.gradle中修改：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiDexEnabled <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="0x02_MultiDex-install_u8FC7_u7A0B"><a href="#0x02_MultiDex-install_u8FC7_u7A0B" class="headerlink" title="0x02 MultiDex.install过程"></a>0x02 MultiDex.install过程</h1><hr>
<p>从MultiDex.install开始分析，传入的context是MultiDexApplication，loader是dalvik.system.PathClassLoader，运行时会先去app的dexDir /data/data/pkgname/code_cache/secondary-dexes下找secondary dex(这里除了main dex，其他都称为secondary dex，即可能存在多个secondary dex)，找到后去检查zip格式，成功就直接installSecondaryDexes，否则会去强制从apk中重新extract secondary dex</p>
<p>MultiDex.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">     ClassLoader loader;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         loader = context.getClassLoader();</span><br><span class="line">         ...</span><br><span class="line">         File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">         List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                <span class="comment">// Try again, but this time force a reload of the zip file.</span></span><br><span class="line">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Second time didn't work, give up</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>MultiDexExtractor.load方法中，sourceApk指向的是/data/app/pkgname.apk，然后通过getZipCrc获取apk的CRC校验码，去与上一次CRC校验码对比，若一致或者不是forceReload，那么直接loadExistingExtractions，loadExistingExtractions会去/data/data/pkgname/code_cache/secondary-dexes/下为已经存在的.dex创建File对象；如果不一致说明apk已经被修改了，dex需要重新抽取，此时执行performExtractions</p>
<p>MultiDexExtractor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span><br><span class="line">        <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"MultiDexExtractor.load("</span> + applicationInfo.sourceDir + <span class="string">", "</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">final</span> File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files;</span><br><span class="line">    <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to reload existing extracted secondary dex files,"</span></span><br><span class="line">                    + <span class="string">" falling back to fresh extraction"</span>, ioe);</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, <span class="string">"load found "</span> + files.size() + <span class="string">" secondary dex files"</span>);</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performExtractions中真正抽取在extract方法中，输入参数分别是：</p>
<ul>
<li>apk(ZipFile)    指向/data/app/pkgname.apk</li>
<li>dexFile(ZipEntry)    指向classes2.dex</li>
<li>extractTo(File)    指向/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes2.zip</li>
<li>extractedFilePrefix(String)    pkgname.apk.classes</li>
</ul>
<p>extract把dexFile写入到extractTo指向的一个entry，其中InputStream读的是apk中的classes2.apk，ZipOutputStream指向的是一个tmpFile，具体步骤为：</p>
<ol>
<li>在/data/data/pkgname/code_cache/secondary-dexes/创建pkgname.apk.classes12345.zip的tmpFile；</li>
<li>对步骤1的tmpFile建立ZipOutputStream；</li>
<li>创建一个指向classes.dex的ZipEntry对象；</li>
<li>向tmpFile写入这个entry；</li>
<li>将tmpFile renameTo extractTo，tmpFile此时还存在；</li>
<li>delete tmpFile；</li>
</ol>
<p>extract的作用就是在/data/data/pkgname/code_cache/secondary-dexes下创建了：</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes2.zip</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes3.zip</p>
<p>…</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classesN.zip</p>
<p>N是MultiDex拆分后dex的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(ZipFile apk, ZipEntry dexFile, File extractTo,</span><br><span class="line">        String extractedFilePrefix)</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InputStream in = apk.getInputStream(dexFile);</span><br><span class="line">    ZipOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    File tmp = File.createTempFile(extractedFilePrefix, EXTRACTED_SUFFIX,</span><br><span class="line">            extractTo.getParentFile());</span><br><span class="line">    Log.i(TAG, <span class="string">"Extracting "</span> + tmp.getPath());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmp)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZipEntry classesDex = <span class="keyword">new</span> ZipEntry(<span class="string">"classes.dex"</span>);</span><br><span class="line">            <span class="comment">// keep zip entry time since it is the criteria used by Dalvik</span></span><br><span class="line">            classesDex.setTime(dexFile.getTime());</span><br><span class="line">            out.putNextEntry(classesDex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> length = in.read(buffer);</span><br><span class="line">            <span class="keyword">while</span> (length != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">                length = in.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            out.closeEntry();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"Renaming to "</span> + extractTo.getPath());</span><br><span class="line">        <span class="keyword">if</span> (!tmp.renameTo(extractTo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to rename \""</span> + tmp.getAbsolutePath() +</span><br><span class="line">                    <span class="string">"\" to \""</span> + extractTo.getAbsolutePath() + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeQuietly(in);</span><br><span class="line">        tmp.delete(); <span class="comment">// return status ignored</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后才到真正的install，MultiDex有三个私有嵌套类V19,V14和V4，对应android 4.4以上，4.0以上和4.0以下版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span><br><span class="line">        InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以4.4为例，V19.install其实就是对输入additionalClassPathEntries反射调用makeDexElements创建Element[]对象，再去修改dalvik.system.BaseDexClassLoader的pathList字段表示的DexPathList类中的dexElements字段内容，把Element[]对象添加进去，这样就可以find在secondary dex中的class了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">            File optimizedDirectory)</span></span><br><span class="line">                    <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">                    NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">/* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span></span><br><span class="line">        Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Field suppressedExceptionsField =</span><br><span class="line">                    findField(loader, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                    (IOException[]) suppressedExceptionsField.get(loader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions =</span><br><span class="line">                        suppressedExceptions.toArray(</span><br><span class="line">                                <span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                IOException[] combined =</span><br><span class="line">                        <span class="keyword">new</span> IOException[suppressedExceptions.size() +</span><br><span class="line">                                        dexElementsSuppressedExceptions.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined,</span><br><span class="line">                        suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                dexElementsSuppressedExceptions = combined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，DexPathList:makeDexElements最终会去做dex2opt，optimizedDirectory就是之前的dexDir，优化后的dex文件是pkgname.apk.classes2.dex，然后dex2opt是比较耗时的，全部放在main线程去处理的话，弄不好会出现ANR</p>
<p>DexPathList.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03__u63A2_u660E_u7684_u5751"><a href="#0x03__u63A2_u660E_u7684_u5751" class="headerlink" title="0x03 探明的坑"></a>0x03 探明的坑</h1><hr>
<ul>
<li><p>坑1 如果secondary dex文件太大，可能导致应用在安装过程中出现ANR，这个在0x02 MultiDex.install过程中也提到过，规避方法下篇文章将继续介绍</p>
</li>
<li><p>坑2 由于Dalvik linearAlloc bug (<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">Issue 22586</a>), 采用MutilDex方案的应用在Android4.0以前的设备上可能会启动失败</p>
</li>
<li><p>坑N-1 由于Dalvik linearAlloc limit (<a href="http://b.android.com/78035" target="_blank" rel="external">Issue 78035</a>)，采用MultiDex方案的应用需要申请一个大内存，运行时可能导致程序crash，这个Issue在Android4.0已经修复了, 不过也可能在低于Android5.0的机器上出现</p>
</li>
<li><p>坑N <a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">main dex capacity exceeded</a>，一边愉快地编译，一边吃着火锅唱着歌，突然出现“main dex capacity exceeded”，build failed了… 这个时候怎么办，一种看似有效的办法是指定dex中的method数，例如：</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android.applicationVariants.all &#123;</span><br><span class="line">    variant -&gt;</span><br><span class="line">        dex.doFirst&#123;</span><br><span class="line">            dex-&gt;</span><br><span class="line">            <span class="keyword">if</span> (dex.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">                dex.additionalParameters = []</span><br><span class="line">            &#125;</span><br><span class="line">                dex.additionalParameters += <span class="string">'--set-max-idx-number=55000'</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然并卵，虽然编译没问题了，但是运行会大概率出现<code>ClassNotFoundException</code>的crash，原因很简单，MultiDex.install之前依赖的所有类，系统的PathClassLoader并不能全部找到！</p>
<p>一个解决办法是build时指定maindexlist.txt，具体可以参考本博客的另一篇文章<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a></p>
<p>好在5.0之后暂时可以忽略这些坑，因为安装app时，ART会扫描apk中所有的classes(..N).dex进行预编译，因此也无需MultiDex支持了。</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/" target="_blank" rel="external">http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u4E3A_u4EC0_u4E48_u9700_u8981MutliDex"><a href="#0x00__u4E3A_u4EC0_u4E48_u9700_u8981MutliDex" class="headerlink" title="0x00 为什么需要MutliDex"></a>0x00 为什么需要MutliDex</h1><hr>
<p>如果你是一名android开发者，随着app功能复杂度的增加，代码量的增多和库的引入，你迟早会在5.0以下的某款设备上遇到：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conversion <span class="keyword">to</span> Dalvik format failed:</span><br><span class="line">Unable <span class="keyword">to</span> execute dex: <span class="function"><span class="keyword">method</span> <span class="title">ID</span> <span class="title">not</span> <span class="title">in</span> [0, 0<span class="title">xffff</span>]:</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trouble writing outpu<span class="variable">t:</span></span><br><span class="line">Too many field reference<span class="variable">s:</span> <span class="number">131000</span>; <span class="built_in">max</span> <span class="keyword">is</span> <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这说明你的app的方法数已经超过<code>65535</code>，如果打算继续兼容5.0以下手机，你可以采用google提供的<a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html">MultiDex方案</a>，但5.0以下系统方法数为什么不能超过65535呢？<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[This is the beginning of the story]]></title>
    <link href="http://www.ct2wj.com/2015/12/22/This-is-the-beginning-of-the-story/"/>
    <id>http://www.ct2wj.com/2015/12/22/This-is-the-beginning-of-the-story/</id>
    <published>2015-12-22T09:53:44.000Z</published>
    <updated>2015-12-22T10:53:20.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/Moving-Castle.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/Moving-Castle.jpg" alt=""></p>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MultiDex中出现的main dex capacity exceeded解决之道]]></title>
    <link href="http://www.ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/"/>
    <id>http://www.ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/</id>
    <published>2015-12-22T03:33:07.000Z</published>
    <updated>2015-12-30T06:11:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr>
<blockquote>
<p>随着业务的日益壮大，在集成构建实践中发现，dalvik上的MultiDex拆包方案频繁出现main dex capacity exceeded导致编译失败，对app的年末上线构成了严峻挑战，本文通过控制maindexlist中class的数量，达到减少MainDex体积，避免exceeded的目的。</p>
</blockquote>
<a id="more"></a>
<h1 id="0x01__u4E3A_u4EC0_u4E48_u4F1Amain_dex_capacity_exceeded"><a href="#0x01__u4E3A_u4EC0_u4E48_u4F1Amain_dex_capacity_exceeded" class="headerlink" title="0x01 为什么会main dex capacity exceeded"></a>0x01 为什么会main dex capacity exceeded</h1><hr>
<p>分析dx.jar源码发现，dx入口类是<code>com.android.dx.command.dexer.Main</code>，当判断出dexOutputArrays.size() &gt; 0后，会抛出DexException，提示<em>“Too many classes in maindexlixt, main dex capacity exceeded”</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">if</span> (args.mainDexListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// with --main-dex-list</span></span><br><span class="line">...</span><br><span class="line">           <span class="keyword">if</span> (dexOutputArrays.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">"Too many classes in "</span> + Arguments.MAIN_DEX_LIST_OPTION</span><br><span class="line">                       + <span class="string">", main dex capacity exceeded"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (args.minimalMainDex) &#123;</span><br><span class="line">               <span class="comment">// start second pass directly in a secondary dex file.</span></span><br><span class="line">               createDexFile();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// remaining files</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">               processOne(fileNames[i], <span class="keyword">new</span> NotFilter(mainPassFilter));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// without --main-dex-list</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">               processOne(fileNames[i], ClassPathOpener.acceptAll);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在processClass()中，发现如果main dex的方法数超过<code>65535</code>，会调用createDexFile()创建一个新的Byte[]对象，被放入dexOutputArrays，导致出现上面的excceed问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span><br><span class="line">   * Processes one classfile.</span><br><span class="line">   *</span><br><span class="line">   * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file, clipped such that it</span><br><span class="line">   * &lt;i&gt;should&lt;/i&gt; correspond to the name of the class it contains</span><br><span class="line">   * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">   * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processClass</span><span class="params">(String name, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">int</span> numMethodIds = outputDex.getMethodIds().items().size();</span><br><span class="line">      <span class="keyword">int</span> numFieldIds = outputDex.getFieldIds().items().size();</span><br><span class="line">      <span class="keyword">int</span> constantPoolSize = cf.getConstantPool().size();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> maxMethodIdsInDex = numMethodIds + constantPoolSize + cf.getMethods().size() +</span><br><span class="line">              MAX_METHOD_ADDED_DURING_DEX_CREATION;</span><br><span class="line">      <span class="keyword">int</span> maxFieldIdsInDex = numFieldIds + constantPoolSize + cf.getFields().size() +</span><br><span class="line">              MAX_FIELD_ADDED_DURING_DEX_CREATION;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (args.multiDex</span><br><span class="line">          <span class="comment">// Never switch to the next dex if current dex is already empty</span></span><br><span class="line">          &amp;&amp; (outputDex.getClassDefs().items().size() &gt; <span class="number">0</span>)</span><br><span class="line">          &amp;&amp; ((maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex) ||</span><br><span class="line">              (maxFieldIdsInDex &gt; args.maxNumberOfIdxPerDex))) &#123;</span><br><span class="line">          DexFile completeDex = outputDex;</span><br><span class="line">          createDexFile();</span><br><span class="line">          <span class="keyword">assert</span>  (completeDex.getMethodIds().items().size() &lt;= numMethodIds +</span><br><span class="line">                  MAX_METHOD_ADDED_DURING_DEX_CREATION) &amp;&amp;</span><br><span class="line">                  (completeDex.getFieldIds().items().size() &lt;= numFieldIds +</span><br><span class="line">                  MAX_FIELD_ADDED_DURING_DEX_CREATION);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x02__u600E_u4E48_u907F_u514D"><a href="#0x02__u600E_u4E48_u907F_u514D" class="headerlink" title="0x02 怎么避免"></a>0x02 怎么避免</h1><hr>
<p>那么问题来了，应该怎么避免出现main dex类中的方法数超65535呢，这里先说结论：<code>关键在控制好maindexlist.txt中类的数量</code></p>
<h1 id="0x03_maindexlist-txt_u7684_u751F_u6210"><a href="#0x03_maindexlist-txt_u7684_u751F_u6210" class="headerlink" title="0x03 maindexlist.txt的生成"></a>0x03 maindexlist.txt的生成</h1><hr>
<p>android gradle plugin中，有一个task是专门负责创建maindexlist.txt的，可以在gradle-core源码中找到：</p>
<p>CreateMainDexList.groovy</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TaskAction</span></span><br><span class="line"><span class="typename">void</span> output() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getAllClassesJarFile() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"No input file"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manifest components plus immediate dependencies must be in the main dex.</span></span><br><span class="line">    File _allClassesJarFile = getAllClassesJarFile()</span><br><span class="line">    Set&lt;String&gt; mainDexClasses = callDx(_allClassesJarFile, getComponentsJarFile())</span><br></pre></td></tr></table></figure>
<p>这里的_allClassesJarFile是输入app的allclasses.jar，第二个jar是componentClasses.jar，componentClasses.jar很重要，一会还会提到，callDx方法不是去做真正的dx，而是调了AndroidBuilder:createMainDexList()</p>
<p>AndroidBuilder.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">callDx</span><span class="params">(File allClassesJarFile, File jarOfRoots)</span> <span class="keyword">throws</span> ProcessException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> variantScope.getGlobalScope().getAndroidBuilder().createMainDexList(</span><br><span class="line">            allClassesJarFile, jarOfRoots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMainDexList()会用到<code>ClassReferenceListBuilder</code>(5.0之前叫<code>MainDexListBuilder</code>), 它的职责之一是用来分析类之间的依赖关系，设置好ProcessInfoBuilder的输入参数后，通过JavaProcessExecutor单独开启进程去执行ClassReferenceListBuilder的main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">createMainDexList</span><span class="params">(</span><br><span class="line">        @NonNull File allClassesJarFile,</span><br><span class="line">        @NonNull File jarOfRoots)</span> <span class="keyword">throws</span> ProcessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">    ProcessInfoBuilder builder = <span class="keyword">new</span> ProcessInfoBuilder();</span><br><span class="line"></span><br><span class="line">    String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX_JAR);</span><br><span class="line">    <span class="keyword">if</span> (dx == <span class="keyword">null</span> || !<span class="keyword">new</span> File(dx).isFile()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"dx.jar is missing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.setClasspath(dx);</span><br><span class="line">    builder.setMain(<span class="string">"com.android.multidex.ClassReferenceListBuilder"</span>);</span><br><span class="line"></span><br><span class="line">    builder.addArgs(jarOfRoots.getAbsolutePath());</span><br><span class="line">    builder.addArgs(allClassesJarFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    CachedProcessOutputHandler processOutputHandler = <span class="keyword">new</span> CachedProcessOutputHandler();</span><br><span class="line"></span><br><span class="line">    mJavaProcessExecutor.execute(builder.createJavaProcess(), processOutputHandler)</span><br><span class="line">            .rethrowFailure()</span><br><span class="line">            .assertNormalExitValue();</span><br><span class="line">    String content = processOutputHandler.getProcessOutput().getStandardOutputAsString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Sets.newHashSet(Splitter.on(<span class="string">'\n'</span>).split(content));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ClassReferenceListBuilder的main方法中，输入参数args0被当做jarOfRoots，args1被当做Path</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">        printUsage();</span><br><span class="line">        System.exit(STATUS_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZipFile jarOfRoots;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jarOfRoots = <span class="keyword">new</span> ZipFile(args[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">"\""</span> + args[<span class="number">0</span>] + <span class="string">"\" can not be read as a zip archive. ("</span></span><br><span class="line">                + e.getMessage() + <span class="string">")"</span>);</span><br><span class="line">        System.exit(STATUS_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Path path = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        path = <span class="keyword">new</span> Path(args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        ClassReferenceListBuilder builder = <span class="keyword">new</span> ClassReferenceListBuilder(path);</span><br><span class="line">        builder.addRoots(jarOfRoots);</span><br><span class="line"></span><br><span class="line">        printList(builder.toKeep);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>为了分析main的两个输入参数，这里用<a href="http://jboss-javassist.github.io/javassist/" target="_blank" rel="external">javassist.jar</a>运行时改写ClassReferenceListBuilder.class，在main方法最前面加上System.err.println（java.util.Arrays.toString(args)），目的是把标准错误输出流打印到终端，为了保险起见，通过PrintWriter同时把参数输出到本地文件log.txt</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/printArgs.jpg" alt=""></p>
<p>实验发现，gradle build进程的标准错误输出流没打印出来，应该被重定向了，好在本地log.txt记录下了参数信息</p>
<pre><code>[[省略...]/release/componentClasses.jar, [省略...]/release/classes.jar]
</code></pre><p>可见<code>arg0是componentClasses.jar， arg1是app完整的classes.jar</code></p>
<p>ClassReferenceListBuilder的addRoots方法中会去遍历componentClasses.jar中.class，并通过addDependencies来分析其依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span><br><span class="line">   * <span class="doctag">@param</span> jarOfRoots Archive containing the class files resulting of the tracing, typically</span><br><span class="line">   * this is the result of running ProGuard.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoots</span><span class="params">(ZipFile jarOfRoots)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">...	</span><br><span class="line">      <span class="comment">// keep direct references of roots (+ direct references hierarchy)</span></span><br><span class="line">      <span class="keyword">for</span> (Enumeration&lt;? extends ZipEntry&gt; entries = jarOfRoots.entries();</span><br><span class="line">              entries.hasMoreElements();) &#123;</span><br><span class="line">          ZipEntry entry = entries.nextElement();</span><br><span class="line">          String name = entry.getName();</span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(CLASS_EXTENSION)) &#123;</span><br><span class="line">              DirectClassFile classFile;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  classFile = path.getClass(name);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Class "</span> + name +</span><br><span class="line">                          <span class="string">" is missing form original class path "</span> + path, e);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              addDependencies(classFile.getConstantPool());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>addDependencies方法从输入的ConstantPool参数，得到import类，并调用addClassWithHierachy继续分析继承关系（其实也可以通过javap -verbose先反汇编，再分析匹配”= class”的字符串来获取，具体可以参考本文的<a href="https://github.com/JLLK/ClassDependenceAnalyser" target="_blank" rel="external">依赖分析工具</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDependencies</span><span class="params">(ConstantPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Constant constant : pool.getEntries()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> CstType) &#123;</span><br><span class="line">            Type type = ((CstType) constant).getClassType();</span><br><span class="line">            String descriptor = type.getDescriptor();</span><br><span class="line">            <span class="keyword">if</span> (descriptor.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastBrace = descriptor.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">                <span class="keyword">if</span> (lastBrace &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    addClassWithHierachy(descriptor.substring(<span class="number">1</span>, descriptor.length()-<span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">assert</span> descriptor.length() &gt; lastBrace + <span class="number">3</span></span><br><span class="line">                    &amp;&amp; descriptor.charAt(lastBrace + <span class="number">1</span>) == <span class="string">'L'</span>;</span><br><span class="line">                    addClassWithHierachy(descriptor.substring(lastBrace + <span class="number">2</span>,</span><br><span class="line">                            descriptor.length() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析继承关系是通过递归分析父类和其实现接口的继承关系，toKeep包含了将要输出到maindexlist的class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addClassWithHierachy</span><span class="params">(String classBinaryName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toKeep.contains(classBinaryName)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String fileName = classBinaryName + CLASS_EXTENSION;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DirectClassFile classFile = path.getClass(fileName);</span><br><span class="line">        toKeep.add(classBinaryName);</span><br><span class="line">        CstType superClass = classFile.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addClassWithHierachy(superClass.getClassType().getClassName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeList interfaceList = classFile.getInterfaces();</span><br><span class="line">        <span class="keyword">int</span> interfaceNumber = interfaceList.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaceNumber; i++) &#123;</span><br><span class="line">            addClassWithHierachy(interfaceList.getType(i).getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore: The referenced type is not in the path it must be part of the libraries.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖关系分析结束后，toKeep输出为maindexlist.txt，这里标准输出被重定向到了maindexlist.txt文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Set&lt;String&gt; toKeep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String classDescriptor : toKeep) &#123;</span><br><span class="line">        System.out.print(classDescriptor);</span><br><span class="line">        System.out.println(CLASS_EXTENSION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04_componentClasses-jar_u7684_u6765_u6E90"><a href="#0x04_componentClasses-jar_u7684_u6765_u6E90" class="headerlink" title="0x04 componentClasses.jar的来源"></a>0x04 componentClasses.jar的来源</h1><hr>
<p>上面分析容易看出，其实<code>componentClasses.jar决定了maindexlist的输出</code></p>
<p>而componentClasses.jar是根据manifest_keep.txt生成的，manifest_keep.txt内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">app</span>.<span class="title">XXXXApplication</span> </span>&#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(android.content.Context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">splash</span>.<span class="title">XXXXActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">app</span>.<span class="title">MainActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">login</span>.<span class="title">xxxx</span>.<span class="title">LoginActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">sidebar</span>.<span class="title">account</span>.<span class="title">XXAccountActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么manifest_keep.txt由谁生成的呢？ 在gradle-core中，CreateManifestKeepList类的generateKeepListFromManifest方法会去解析AndroidManifest.xml文件</p>
<p>CreateManifestKeepList.groovy</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="annotation">@TaskAction</span></span><br><span class="line">   <span class="typename">void</span> generateKeepListFromManifest() &#123;</span><br><span class="line">       SAXParser parser = SAXParserFactory.newInstance().newSAXParser()</span><br><span class="line"></span><br><span class="line">       Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(getOutputFile()))</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           parser.parse(getManifest(), <span class="keyword">new</span> ManifestHandler(out))</span><br><span class="line"></span><br><span class="line">           <span class="comment">// add a couple of rules that cannot be easily parsed from the manifest.</span></span><br><span class="line">           out.write(</span><br><span class="line"><span class="string">"""-keep public class * extends android.app.backup.BackupAgent &#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">&#125;</span><br><span class="line">-keep public class * extends java.lang.annotation.Annotation &#123;</span><br><span class="line">   *;</span><br><span class="line">&#125;</span><br><span class="line">"""</span>)</span><br></pre></td></tr></table></figure>
<p>这里的getOutputFile拿到的File对象指向的是manifest_keep.txt，私有内部类ManifestHandler的startElement方法，CreateManifestKeepList.KEEP_SPECS[qName]决定哪些类需要放入manifest_keep.txt</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ManifestHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Writer out</span><br><span class="line"></span><br><span class="line">    <span class="title">ManifestHandler</span><span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.out = out</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// IJ thinks the qualified reference to KEEP_SPECS is not needed but Groovy needs</span></span><br><span class="line">        <span class="comment">// it at runtime?!?</span></span><br><span class="line">        <span class="comment">//noinspection UnnecessaryQualifiedReference</span></span><br><span class="line">        String keepSpec = CreateManifestKeepList.KEEP_SPECS[qName]</span><br><span class="line">        <span class="keyword">if</span> (keepSpec) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> keepIt = <span class="function"><span class="keyword">true</span></span><br><span class="line">            <span class="title">if</span> <span class="params">(CreateManifestKeepList.<span class="keyword">this</span>.filter)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// for ease of use, turn 'attr' into a simple map</span></span><br><span class="line">                Map&lt;String, String&gt; attrMap = [:]</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attr.getLength(); i++) &#123;</span><br><span class="line">                    attrMap[attr.getQName(i)] = attr.getValue(i)</span><br><span class="line">                &#125;</span><br><span class="line">                keepIt = CreateManifestKeepList.<span class="keyword">this</span>.filter(qName, attrMap)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (keepIt) &#123;</span><br><span class="line">                String nameValue = attr.getValue(<span class="string">'android:name'</span>)</span><br><span class="line">                <span class="keyword">if</span> (nameValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.write((String) <span class="string">"-keep class $&#123;nameValue&#125; $keepSpec\n"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来过滤的KEEP_SPECS为CreateManifestKeepList的static字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="type">String</span> <span class="type">DEFAULT_KEEP_SPEC</span> = <span class="string">"&#123; &lt;init&gt;(); &#125;"</span></span><br><span class="line">   <span class="keyword">private</span> static <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; <span class="type">KEEP_SPECS</span> = [</span><br><span class="line">       <span class="symbol">'applicatio</span>n'       : <span class="string">"""&#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">   void attachBaseContext(android.content.Context);</span><br><span class="line">&#125;"""</span>,</span><br><span class="line">       <span class="symbol">'activit</span>y'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'servic</span>e'           : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'receive</span>r'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'provide</span>r'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'instrumentatio</span>n'   : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
<p>可见，AndroidManifest.xml中<code>application</code>,<code>activity</code>,<code>service</code>,<code>receiver</code>,<code>provider</code>,<code>instrumentation</code>这6种标签的类会被标记为root class，用来产生maindexlist.txt</p>
<h1 id="0x05__u89E3_u51B3_u4E4B_u9053"><a href="#0x05__u89E3_u51B3_u4E4B_u9053" class="headerlink" title="0x05 解决之道"></a>0x05 解决之道</h1><hr>
<p>本文直接绕过gradle build工具make componentClasses.jar的方式，不纠结于如何控制componentClasses.jar，而是指定哪些类需要放进maindexlist，达到减少maindexlist class数量，避免出现main dex capacity exceeded。</p>
<p>首先从app的com.xxxx.sdk.app.XXXXApplication类出发，分析出MultiDex.install之前的所有必须打进main dex中的类（MultiDex包也需并入分析），输出到maindexlist.txt。<code>正确分析依赖关系非常重要</code>，否则运行时一定出现ClassNotFoundException。</p>
<p>另外加载过程中，被加载类的static initializer块里（clinit）使用的类和inner类也会被加载器主动load，需确保在maindexlist.txt中，可以使用本人用scala写的<a href="https://github.com/JLLK/ClassDependenceAnalyser" target="_blank" rel="external">依赖分析工具</a>来进行分析，得到maindexlist.txt。</p>
<p>最后，还需在build.gradle中加上：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">"dex"</span>)</span><br><span class="line">    &#125;.each &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// optional</span></span><br><span class="line">    dx.additionalParameters += <span class="string">"--main-dex-list=$projectDir/maindexlist.txt"</span></span><br><span class="line">    dx.additionalParameters += <span class="string">"--minimal-main-dex"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终maindexlist.txt中类的数量成功由4000减少到1116，main dex由7M减少到1.3M，du -sh *.dex输出如下：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/maindex_output.png?imageView2/2/w/150" alt=""></p>
<p>从此再也不用担心main dex capacity exceeded了^_-</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><hr>
<blockquote>
<p>随着业务的日益壮大，在集成构建实践中发现，dalvik上的MultiDex拆包方案频繁出现main dex capacity exceeded导致编译失败，对app的年末上线构成了严峻挑战，本文通过控制maindexlist中class的数量，达到减少MainDex体积，避免exceeded的目的。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="build" scheme="http://www.ct2wj.com/tags/build/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
</feed>
