<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[tomchen&fleur.wang's moving castle]]></title>
  <subtitle><![CDATA[This dog is lazy, left nothing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.ct2wj.com/"/>
  <updated>2016-05-06T00:40:56.000Z</updated>
  <id>http://www.ct2wj.com/</id>
  
  <author>
    <name><![CDATA[tomchen]]></name>
    <email><![CDATA[tomchenv5@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[shadowsocks-android源码解析]]></title>
    <link href="http://www.ct2wj.com/2016/02/28/shadowsocks-android-source-code-analysis/"/>
    <id>http://www.ct2wj.com/2016/02/28/shadowsocks-android-source-code-analysis/</id>
    <published>2016-02-28T08:41:44.000Z</published>
    <updated>2016-05-06T00:40:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u7B80_u4ECB"><a href="#0x00__u7B80_u4ECB" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p><a href="https://github.com/shadowsocks/shadowsocks-android" target="_blank" rel="external">shadowsocks-android</a>(ss-android)是一款android上的科学上网软件，特点是无需root权限就能实现全局代理。作为一个shadowsocks重度使用者，本来想学习一下，但发现网上相关文章和资料还比较少，因此有了本篇文章，旨在分享自己对ss-android源码的一些理解。本文分析的源码基于ss-android的<a href="https://github.com/shadowsocks/shadowsocks-android/releases/tag/v2.9.11" target="_blank" rel="external">2.9.11</a>版本。</p>
<hr>
<h1 id="0x01_ss-android_u8FDB_u7A0B_u6982_u8FF0"><a href="#0x01_ss-android_u8FDB_u7A0B_u6982_u8FF0" class="headerlink" title="0x01 ss-android进程概述"></a>0x01 ss-android进程概述</h1><p>本文先从整体上阐述ss-android进程之间的关系，然后从每个进程角度出发，结合源码分析ss-android科学上网的实现原理。ss-android启动时默认工作在vpn模式，创建2个java进程<strong>shadowsocks</strong>，<strong>shadowsocks:vpn</strong>以及4个native进程<strong>ss-local</strong>、<strong>pdnsd</strong>、<strong>ss-tunel</strong>、<strong>tun2socks</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u0_a124   <span class="number">14935</span> <span class="number">1857</span>  <span class="number">1058332</span> <span class="number">56560</span> SyS_epoll_ <span class="number">00000000</span> S com.github.shadowsocks:vpn</span><br><span class="line">u0_a124   <span class="number">16336</span> <span class="number">1857</span>  <span class="number">1235568</span> <span class="number">88380</span> SyS_epoll_ <span class="number">00000000</span> S com.github.shadowsocks</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u0_a124   <span class="number">20419</span> <span class="number">14935</span> <span class="number">3376</span>   <span class="number">1136</span>  SyS_epoll_ <span class="number">00000000</span> S /data/data/com.github.shadowsocks/ss-local</span><br><span class="line">u0_a124   <span class="number">20421</span> <span class="number">14935</span> <span class="number">7688</span>   <span class="number">804</span>   <span class="keyword">do</span>_sigtime <span class="number">00000000</span> S /data/data/com.github.shadowsocks/pdnsd</span><br><span class="line">u0_a124   <span class="number">20425</span> <span class="number">14935</span> <span class="number">3112</span>   <span class="number">940</span>   SyS_epoll_ <span class="number">00000000</span> S /data/data/com.github.shadowsocks/ss-tunnel</span><br><span class="line">u0_a124   <span class="number">20431</span> <span class="number">14935</span> <span class="number">3812</span>   <span class="number">1420</span>  SyS_epoll_ <span class="number">00000000</span> S /data/data/com.github.shadowsocks/tun2socks</span><br></pre></td></tr></table></figure>
<p>ss-android进程启动流程以及进程间通信关系图：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">shadowsocks =&#62; shadowsocks:vpn =&#62; ss-local =&#62; pdnsd =&#62; ss-tunnel =&#62; tun2socks</span><br></pre></td></tr></table></figure>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/ProcessOfShadowsocks.jpg" alt=""></p>
<a id="more"></a>
<hr>
<h1 id="0x02_shadowsocks_u4E0Eshadowsocks_3Avpn"><a href="#0x02_shadowsocks_u4E0Eshadowsocks_3Avpn" class="headerlink" title="0x02 shadowsocks与shadowsocks:vpn"></a>0x02 shadowsocks与shadowsocks:vpn</h1><p>shadowsocks进程主要负责UI展示，用户可以设置shadowsocks服务器地址端口，选择加密算法，工作模式（vpn或nat），是否采用udp转发等。shadowsocks在<code>onCreate</code>时会去<code>attachService</code>，默认bind的是<code>ShadowsocksVpnService</code>。</p>
<p>ServiceBoundContext.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attachService</span>(</span>callback: <span class="type">IShadowsocksServiceCallback</span>.<span class="type">Stub</span> = <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.callback = callback</span><br><span class="line">  <span class="keyword">if</span> (bgService == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> s =</span><br><span class="line">      <span class="keyword">if</span> (<span class="type">ShadowsocksApplication</span>.isVpnEnabled) classOf[<span class="type">ShadowsocksVpnService</span>] <span class="keyword">else</span> classOf[<span class="type">ShadowsocksNatService</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="keyword">this</span>, s)</span><br><span class="line">    intent.setAction(<span class="type">Action</span>.<span class="type">SERVICE</span>)</span><br><span class="line"></span><br><span class="line">    connection = <span class="keyword">new</span> <span class="type">ShadowsocksServiceConnection</span>()</span><br><span class="line">    bindService(intent, connection, <span class="type">Context</span>.<span class="type">BIND_AUTO_CREATE</span>)</span><br><span class="line">    startService(intent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ShadowsocksVpnService</code>工作在shadowsocks:vpn进程，shadowsocks:vpn是后台进程，除了启动native进程，流量统计等功能也是shadowsocks:vpn和shadowsocks协作完成的。shadowsocks通过<code>bindService</code>和shadowsocks:vpn建立Binder IPC，注册跨进程callback将流量变化展示到shadowsocks。</p>
<p>当用户点击浮窗开启vpn时，shadowsocks执行<code>prepareStartService</code>：</p>
<p>Shadowsocks.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepareStartService</span>(</span>) &#123;</span><br><span class="line">  <span class="type">ThrowableFuture</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">ShadowsocksApplication</span>.isVpnEnabled) &#123;</span><br><span class="line">      <span class="keyword">val</span> intent = <span class="type">VpnService</span>.prepare(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, <span class="type">Shadowsocks</span>.<span class="type">REQUEST_CONNECT</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler.post(() =&gt; onActivityResult(<span class="type">Shadowsocks</span>.<span class="type">REQUEST_CONNECT</span>, <span class="type">Activity</span>.<span class="type">RESULT_OK</span>, <span class="literal">null</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      serviceStart()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>VpnService.prepare</code>去检查系统当前是否存在一个vpn连接。如果不存在，会返回一个让用户确认开启vpn界面的intent，这时<code>onActivityResult</code>传入<code>Activity.RESULT_OK</code>。在返回<code>Activity.RESULT_OK</code>的情况下，shadowsocks会执行<code>bgService.start</code>，准备让shadowsocks:vpn启动native进程。</p>
<p>Shadowsocks.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onActivityResult</span>(</span>requestCode: <span class="type">Int</span>, resultCode: <span class="type">Int</span>, data: <span class="type">Intent</span>) = resultCode <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Activity</span>.<span class="type">RESULT_OK</span> =&gt;</span><br><span class="line">    serviceStart()</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">    cancelStart()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">serviceStart</span>(</span>) &#123;</span><br><span class="line">   bgService.start(<span class="type">ConfigUtils</span>.load(<span class="type">ShadowsocksApplication</span>.settings))</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>bgServive.start</code>会在shadowsocks:vpn中调起<code>startRunner</code>， <code>ShadowsocksVpnThread.start</code>会另起线程创建socket（socket文件是/data/data/com.github.shadowsocks/protect_path），以unix domain socket的方式和native进程ss-local进行IPC，目的是把远程shadowsocks服务端地址“保护”起来，原因后面会详细分析。</p>
<p>接着做dns解析，<code>Utils.resolve</code>得到远程shadowsocks代理服务器的ip地址。</p>
<p>ShadowsocksVpnService.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">startRunner</span>(</span>config: <span class="type">Config</span>) &#123;</span><br><span class="line">   <span class="keyword">super</span>.startRunner(config)</span><br><span class="line">   vpnThread = <span class="keyword">new</span> <span class="type">ShadowsocksVpnThread</span>(<span class="keyword">this</span>)</span><br><span class="line">   vpnThread.start()</span><br><span class="line">...</span><br><span class="line">   <span class="type">ThrowableFuture</span> &#123;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">...</span><br><span class="line">       <span class="comment">// Resolve the server address</span></span><br><span class="line">       <span class="keyword">var</span> resolved: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">       <span class="keyword">if</span> (!<span class="type">Utils</span>.isNumeric(config.proxy)) &#123;</span><br><span class="line">         <span class="type">Utils</span>.resolve(config.proxy, enableIPv6 = <span class="literal">true</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="type">Some</span>(addr) =&gt;</span><br><span class="line">             config.proxy = addr</span><br><span class="line">             resolved = <span class="literal">true</span></span><br><span class="line">           <span class="keyword">case</span> <span class="type">None</span> =&gt; resolved = <span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         resolved = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (resolved &amp;&amp; handleConnection) &#123;</span><br><span class="line">         changeState(<span class="type">State</span>.<span class="type">CONNECTED</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>服务器地址解析成功后，最终调用<code>handleConnection</code>去启动ss-local、tun2socks、pdnsd和ss-tunnel。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Called when the activity is first created. */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleConnection</span>:</span> <span class="type">Boolean</span> = &#123;</span><br><span class="line">  startShadowsocksDaemon()</span><br><span class="line">  <span class="keyword">if</span> (!config.isUdpDns) &#123;</span><br><span class="line">    startDnsDaemon()</span><br><span class="line">    startDnsTunnel()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> fd = startVpn()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tries = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (tries &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span> * tries)</span><br><span class="line">      <span class="keyword">if</span> (<span class="type">System</span>.sendfd(fd) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      tries += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x03_ss-local"><a href="#0x03_ss-local" class="headerlink" title="0x03 ss-local"></a>0x03 ss-local</h1><p>ss-local是本地socks代理服务进程，可以看作一个通道，通道一端连着墙外的shawdowsocks服务器，另一端接着手机的本地客户端进程。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#26412;&#22320;&#23458;&#25143;&#31471;&#36827;&#31243; &#60;=&#62;&#65288;&#26412;&#22320;&#26381;&#21153;&#31471;:1080&#65289;ss-local (&#26412;&#22320;socks&#23458;&#25143;&#31471;) &#60;==| GFW |==&#62; &#36828;&#31243;socks&#26381;&#21153;&#31471;</span><br></pre></td></tr></table></figure>
<p>那么ss-local是如何让客户端进程把数据发送到远程socks服务端呢？</p>
<p>ss-local文件执行后，<code>main</code>函数会在<code>create_and_bind</code>创建和返回本地服务端socket fd，监听本地进程在localhost:1080上的连接请求。<code>ev_io_init</code>用来在fd上注册监听事件以及对应的回调函数，当listenfd上<code>EV_READ</code>发生时，<code>accept_cb</code>被回调。内核在某个fd上准备好数据后，这个fd就是<strong>可读</strong>的，<code>EV_READ</code>就会在新的轮询中被触发；同样，如果send buffer还有空间，就是<strong>可写</strong>的，<code>EV_WRITE</code>会被触发。</p>
<p>local.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;	 ...</span><br><span class="line">    <span class="comment">// Setup socket</span></span><br><span class="line">    <span class="keyword">int</span> listenfd;</span><br><span class="line">    listenfd = create_and_bind(local_addr, local_port);</span><br><span class="line">    <span class="keyword">if</span> (listenfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        FATAL(<span class="string">"bind() error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, SOMAXCONN) == -<span class="number">1</span>) &#123;</span><br><span class="line">        FATAL(<span class="string">"listen() error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setnonblocking(listenfd);</span><br><span class="line"></span><br><span class="line">    listen_ctx.fd = listenfd;</span><br><span class="line"></span><br><span class="line">    ev_io_init(&amp;listen_ctx.io, accept_cb, listenfd, EV_READ);</span><br><span class="line">    ev_io_start(loop, &amp;listen_ctx.io);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create_and_bind</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (rp = result; rp != <span class="literal">NULL</span>; rp = rp-&gt;ai_next) &#123;</span><br><span class="line">    listen_sock = socket(rp-&gt;ai_family, rp-&gt;ai_socktype, rp-&gt;ai_protocol);</span><br></pre></td></tr></table></figure>
<p>listenfd收到数据时，说明有本地客户端进程连接进来了，<code>accept_cb</code>被回调，为返回的serverfd注册I/O事件回调函数<code>server_recv_cb</code>和<code>server_send_cb</code>。当本地客户端进程有数据到达时，<code>server_recv_cb</code>被回调，<code>recv</code>接收socket的数据到<code>buf-&gt;array</code>（此时的buf是<code>server-&gt;buf</code>）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_cb</span><span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">listen_ctx_t</span> *listener = (<span class="keyword">listen_ctx_t</span> *)w;</span><br><span class="line">    <span class="keyword">int</span> serverfd           = accept(listener-&gt;fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">server_t</span> *server = new_server(serverfd, listener-&gt;method);</span><br><span class="line">    server-&gt;listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> server_t *<span class="title">new_server</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> method)</span></span><br><span class="line"></span>&#123;	 ...</span><br><span class="line">    server-&gt;fd                  = fd;	</span><br><span class="line">	 ...</span><br><span class="line">    ev_io_init(&amp;server-&gt;recv_ctx-&gt;io, server_recv_cb, fd, EV_READ);</span><br><span class="line">    ev_io_init(&amp;server-&gt;send_ctx-&gt;io, server_send_cb, fd, EV_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_recv_cb</span><span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></span><br><span class="line"></span>&#123;	...</span><br><span class="line">    <span class="keyword">if</span> (remote == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        buf = server-&gt;buf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = remote-&gt;buf;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    r = recv(server-&gt;fd, buf-&gt;<span class="built_in">array</span>, BUF_SIZE, <span class="number">0</span>); </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><code>server_recv_cb</code>函数比较长，当<code>server-&gt;stage</code>到达阶段<code>5</code>时，<code>create_remote</code>会根据前面解析好的shadowsocks服务器ip和端口来创建socket，得到remotefd。下一次循环ss-local作为本地socks客户端，会尝试与远程shadowsocks服务器建立连接。</p>
<p><code>server_recv_cb</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">                server-&gt;stage = <span class="number">5</span>;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> ((acl &amp;&amp; (request-&gt;atyp == <span class="number">1</span> || request-&gt;atyp == <span class="number">4</span>) &amp;&amp; acl_match_ip(host))) &#123;</span><br><span class="line">                    <span class="keyword">struct</span> sockaddr_storage storage;</span><br><span class="line">                    <span class="built_in">memset</span>(&amp;storage, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">                    <span class="keyword">if</span> (get_sockaddr(host, port, &amp;storage, <span class="number">0</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        remote         = create_remote(server-&gt;listener, (<span class="keyword">struct</span> sockaddr *)&amp;storage);</span><br><span class="line">                        remote-&gt;direct = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    remote = create_remote(server-&gt;listener, <span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (server-&gt;stage == <span class="number">5</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">      <span class="keyword">if</span> (!remote-&gt;send_ctx-&gt;connected) &#123;</span><br><span class="line">...</span><br><span class="line">          remote-&gt;buf-&gt;idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!fast_open || remote-&gt;direct) &#123;</span><br><span class="line">              <span class="comment">// connecting, wait until connected</span></span><br><span class="line">              connect(remote-&gt;fd, (<span class="keyword">struct</span> sockaddr *)&amp;(remote-&gt;addr), remote-&gt;addr_len);</span><br></pre></td></tr></table></figure>
<p>这里的buf还是<code>server-&gt;buf</code>，并且<code>buf-&gt;len &gt; 0</code>。远程socks服务端建立连接成功后，把<code>server-&gt;buf-&gt;array</code>数据直接<code>memcpy</code>到<code>remote-&gt;buf-&gt;array</code>。为一下步数据加密做准备。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (remote == <span class="type">NULL</span>) &#123;</span><br><span class="line">        buf = server-&gt;buf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = remote-&gt;buf;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> (!remote-&gt;direct) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (auth) &#123;</span><br><span class="line">                        abuf-&gt;<span class="built_in">array</span>[<span class="number">0</span>] |= <span class="type">ONETIMEAUTH_FLAG</span>;</span><br><span class="line">                        ss_onetimeauth(abuf, server-&gt;e_ctx-&gt;evp.iv, <span class="type">BUF_SIZE</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    brealloc(remote-&gt;buf, buf-&gt;len + abuf-&gt;len, <span class="type">BUF_SIZE</span>);</span><br><span class="line">                    memcpy(remote-&gt;buf-&gt;<span class="built_in">array</span>, abuf-&gt;<span class="built_in">array</span>, abuf-&gt;len);</span><br><span class="line">                    remote-&gt;buf-&gt;len = buf-&gt;len + abuf-&gt;len;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (buf-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (auth) &#123;</span><br><span class="line">                            ss_gen_hash(buf, &amp;remote-&gt;counter, server-&gt;e_ctx, <span class="type">BUF_SIZE</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        memcpy(remote-&gt;buf-&gt;<span class="built_in">array</span> + abuf-&gt;len, buf-&gt;<span class="built_in">array</span>, buf-&gt;len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (buf-&gt;len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        memcpy(remote-&gt;buf-&gt;<span class="built_in">array</span>, buf-&gt;<span class="built_in">array</span>, buf-&gt;len);</span><br><span class="line">                        remote-&gt;buf-&gt;len = buf-&gt;len;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>加密初始化时，ss-local-vpn.conf中password作为<code>salt</code>参与加密过程，method在<code>supported_ciphers</code>中找到method对应的下标m，决定对称加密算法(推荐使用<code>aes-256-cfb</code>)。确定算法后，远程socks服务端采用相同的算法进行解密。这样ss-local和远程shadowsocks服务进程就可以理解双方传递的数据了。注意，<strong>这里并不需要和服务端进行密钥交换，加密的设计初衷只是为了混淆传数据，增加GFW检查流量特征的计算量</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enc_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pass, <span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = TABLE;</span><br><span class="line">    <span class="keyword">if</span> (method != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (m = TABLE; m &lt; CIPHER_NUM; m++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(method, supported_ciphers[m]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line">        enc_key_init(m, pass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bytes_to_key</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bytes_to_key</span><span class="params">(<span class="keyword">const</span> cipher_kt_t *cipher, <span class="keyword">const</span> digest_type_t *md,</span><br><span class="line">                 <span class="keyword">const</span> uint8_t *pass, uint8_t *key, uint8_t *iv)</span></span><br><span class="line"></span>&#123; ...</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(USE_CRYPTO_OPENSSL)</span></span><br><span class="line">    <span class="keyword">return</span> EVP_BytesToKey(cipher, md, <span class="literal">NULL</span>, pass, datal, <span class="number">1</span>, key, iv);</span><br></pre></td></tr></table></figure>
<p><code>enc_key_init</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enc_key_init</span><span class="params">(<span class="keyword">int</span> method, <span class="keyword">const</span> <span class="keyword">char</span> *pass)</span></span><br><span class="line"></span>&#123;...</span><br><span class="line">        cipher = (<span class="keyword">cipher_kt_t</span> *)get_cipher_type(method)</span><br><span class="line">...</span><br><span class="line">    enc_key_len = bytes_to_key(cipher, md, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)pass, enc_key, iv);</span><br></pre></td></tr></table></figure>
<p><code>EVP_BytesToKey</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EVP_BytesToKey</span><span class="params">(<span class="keyword">const</span> EVP_CIPHER *type, <span class="keyword">const</span> EVP_MD *md, </span><br><span class="line">	     <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *salt, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">int</span> datal,</span><br><span class="line">	     <span class="keyword">int</span> count, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">char</span> *iv)</span></span><br><span class="line"></span>&#123; ...</span><br><span class="line">		<span class="keyword">if</span> (salt != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">if</span> (!EVP_DigestUpdate(&amp;c,salt,PKCS5_SALT_LEN))</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br></pre></td></tr></table></figure>
<p>接着，对数据加密。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// local socks5 server</span></span><br><span class="line">        <span class="keyword">if</span> (server<span class="subst">-&gt;</span>stage == <span class="number">5</span>) &#123;</span><br><span class="line"><span class="attribute">...</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="subst">!</span>remote<span class="subst">-&gt;</span>direct <span class="subst">&amp;&amp;</span> remote<span class="subst">-&gt;</span>send_ctx<span class="subst">-&gt;</span>connected <span class="subst">&amp;&amp;</span> auth) &#123;</span><br><span class="line">                ss_gen_hash(remote<span class="subst">-&gt;</span>buf, <span class="subst">&amp;</span>remote<span class="subst">-&gt;</span>counter, server<span class="subst">-&gt;</span>e_ctx, BUF_SIZE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert shadowsocks header</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="subst">!</span>remote<span class="subst">-&gt;</span>direct) &#123;</span><br><span class="line"><span class="variable">#ifdef</span> ANDROID</span><br><span class="line">                tx += remote<span class="subst">-&gt;</span>buf<span class="subst">-&gt;</span>len;</span><br><span class="line"><span class="variable">#endif</span></span><br><span class="line">                int err = ss_encrypt(remote<span class="subst">-&gt;</span>buf, server<span class="subst">-&gt;</span>e_ctx, BUF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="attribute">...</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>如果内核空间remotefd的send buffer还没满，<code>remote_send_cb</code>被回调，若<code>remote-&gt;buf-&gt;len</code>长度大于0，说明有数据正在等待发送，ss-local会通过<code>send</code>直接发送给远程socks服务端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remote_send_cb</span><span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></span><br><span class="line"></span>&#123;	...</span><br><span class="line">    <span class="keyword">remote_t</span> *remote              = remote_send_ctx-&gt;remote;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (remote-&gt;buf-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// close and free</span></span><br><span class="line">        close_and_free_remote(EV_A_ remote);</span><br><span class="line">        close_and_free_server(EV_A_ server);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// has data to send</span></span><br><span class="line">        <span class="keyword">ssize_t</span> s = send(remote-&gt;fd, remote-&gt;buf-&gt;<span class="built_in">array</span> + remote-&gt;buf-&gt;idx,</span><br><span class="line">                         remote-&gt;buf-&gt;len, <span class="number">0</span>);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析到这儿，ss-local发送数据给远程shadowsocks服务端的基本流程清楚了，但还有个问题，<strong>本地连上ss-local是哪个进程？</strong></p>
<hr>
<h1 id="0x04_tun2socks"><a href="#0x04_tun2socks" class="headerlink" title="0x04 tun2socks"></a>0x04 tun2socks</h1><p>由于ss-local连上了shadowsocks服务器，需要科学上网的本地进程都得想办法连上ss-local。要让进程都连上ss-local要做额外配置工作，最好是能有一个<strong>全局代理</strong>把流量都转给ss-local。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#26412;&#22320;&#36827;&#31243; &#60;=&#62; &#20840;&#23616;&#20195;&#29702; &#60;=&#62; ss-local</span><br></pre></td></tr></table></figure>
<p>Android 4.0推出了<code>VpnSerivce</code>，目的是让开发者在没有root权限的情况下也能实现全局代理。<code>VpnService</code>会创建虚拟网卡设备：<strong>tun设备</strong>（对应的文件叫<strong>tun设备文件</strong>）。vpn进程shadowsocks:vpn拿到tunfd后就拥有了读写虚拟网卡ip包的能力，但是采用socks5协议的ss-local工作在L4，没法直接处理L3的ip包，所以<strong>tun2socks</strong>成了让ss-android成为全局socks代理的关键。tun2socks在用户态实现了一个轻量级的TCP/IP栈（lwip），来实现L3的包转成L4的数据流。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#26412;&#22320;&#36827;&#31243; =&#62; tun&#35774;&#22791;&#65288;&#34394;&#25311;&#32593;&#21345;&#65289;=&#62; tun2socks =&#62; ss-local =&#62; &#29289;&#29702;&#32593;&#21345; =&#62; ...</span><br></pre></td></tr></table></figure>
<p>有了tun2socks的L3转L4的能力，还剩下2个关键问题需要解决：</p>
<ul>
<li>问题1：<strong>怎么让tun2socks直接读取tun设备的ip包？</strong></li>
<li>问题2：<strong>怎么让所有的包都经过tun设备？</strong></li>
</ul>
<p>问题1的解决办法是让tun2socks跨进程拿到tunfd。tunfd是在shadowsocks:vpn进程<code>startVpn</code>时返回的。tun2socks是native进程，而shadowsocks:vpn是java进程，为了在不同的进程中共享tunfd，shadowsocks:vpn作为客户端进程和tun2socks通过unix domain socket方式进行IPC，对应的socket文件是/data/data/com.github.shadowsocks/sock_path。通过jni方法<code>System.sendfd</code>传递tunfd。</p>
<p>ShadowsocksVpnService.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">handleConnection</span>:</span> <span class="type">Boolean</span> = &#123;</span><br><span class="line">    startShadowsocksDaemon()</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">val</span> fd = startVpn()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> tries = <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (tries &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">Thread</span>.sleep(<span class="number">1000</span> * tries)</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">System</span>.sendfd(fd) != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        tries += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>System.sendfd</code>对应native方法<code>Java_com_github_shadowsocks_system_sendfd</code>。shadowsocks:vpn拿到tunfd后，利用<code>ancil_send_fd</code>传给tun2socks进程。这样tun2socks就具备直接读写虚拟网卡ip包的能力了。</p>
<p>System.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Java_com_github_shadowsocks_system_sendfd</span><span class="params">(JNIEnv *env, jobject thiz, jint tun_fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">struct</span> sockaddr_un addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (jint)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, <span class="string">"/data/data/com.github.shadowsocks/sock_path"</span>, <span class="keyword">sizeof</span>(addr.sun_path)-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> (jint)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ancil_send_fd(fd, tun_fd)) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> (jint)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tun2socks能直接读写ip包还只是开始，问题2<strong>怎么让所有的包都经过tun设备</strong>，我们看一下tunfd的创建过程。</p>
<p>ShadowsocksVpnService.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">val</span> <span class="type">VPN_MTU</span> = <span class="number">1500</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">PRIVATE_VLAN</span> = <span class="string">"26.26.26.%s"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">startVpn</span>(</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = <span class="keyword">new</span> <span class="type">Builder</span>()</span><br><span class="line">    builder</span><br><span class="line">      .setSession(config.profileName)</span><br><span class="line">      .setMtu(<span class="type">VPN_MTU</span>)</span><br><span class="line">      .addAddress(<span class="type">PRIVATE_VLAN</span>.formatLocal(<span class="type">Locale</span>.<span class="type">ENGLISH</span>, <span class="string">"1"</span>), <span class="number">24</span>)</span><br><span class="line">      .addDnsServer(<span class="string">"8.8.8.8"</span>)</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (config.route == <span class="type">Route</span>.<span class="type">ALL</span> || config.route == <span class="type">Route</span>.<span class="type">BYPASS_CHN</span>) &#123;</span><br><span class="line">      builder.addRoute(<span class="string">"0.0.0.0"</span>, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    builder.addRoute(<span class="string">"8.8.0.0"</span>, <span class="number">16</span>)</span><br><span class="line">...</span><br><span class="line">      conn = builder.establish()</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">val</span> fd = conn.getFd</span><br></pre></td></tr></table></figure>
<p>首先，在用户允许Vpn的情况下，shadowsocks:vpn会尝试用<code>builder.establish</code>创建tun设备。<code>conn.getFd</code>返回的fd就是tun设备fd，前面我们知道，有了tunfd可以读写ip数据包了。</p>
<p>ps：vpn连接在整个系统中只能存在一个，新的vpn连接会去覆盖老的。tunfd被close了或者vpn进程挂了，网络就会自动恢复。</p>
<p>接着，<code>builder.addAddress</code>添加<code>26.26.26.1/24</code>到tun设备，作为tun设备ip地址。<code>addDnsServer</code>把<code>8.8.8.8</code>（google dns服务器地址）作为vpn连接的dns解析服务器地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@android:/dev <span class="comment"># ifconfig tun0</span></span><br><span class="line">tun0: ip <span class="number">26.26</span>.<span class="number">26.1</span> mask <span class="number">255.255</span>.<span class="number">255.0</span> flags [up point-to-point running]</span><br></pre></td></tr></table></figure>
<p>如果Route设置工作在<code>ALL</code>或<code>BYPASS_CHN</code>模式，路由<code>0.0.0.0:0</code>被添加到tun设备，不管包的目标ip是多少都保证经过tun设备，也就是说，<code>ALL</code>或<code>BYPASS_CHN</code>模式下<strong>所有本地流量</strong>都会从tun设备出去。此外，默认<code>8.8.0.0:16</code>也添加到tun设备路由，保证至少到google dns服务器做dns解析的包经过tun设备。</p>
<p>ip路由信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@android:/ <span class="comment"># ip r</span></span><br><span class="line"><span class="number">0.0</span>.<span class="number">0.0</span>/<span class="number">1</span> dev tun0  scope link</span><br><span class="line">default via <span class="number">10.0</span>.<span class="number">3.2</span> dev eth1</span><br><span class="line">default via <span class="number">10.0</span>.<span class="number">3.2</span> dev eth1  metric <span class="number">205</span></span><br><span class="line"><span class="number">8.8</span>.<span class="number">0.0</span>/<span class="number">16</span> dev tun0  scope link</span><br><span class="line"><span class="number">10.0</span>.<span class="number">3.0</span>/<span class="number">24</span> dev eth1  proto kernel  scope link  src <span class="number">10.0</span>.<span class="number">3.15</span>  metric <span class="number">205</span></span><br><span class="line"><span class="number">10.0</span>.<span class="number">3.2</span> dev eth1  scope link</span><br><span class="line"><span class="number">26.26</span>.<span class="number">26.0</span>/<span class="number">24</span> dev tun0  proto kernel  scope link  src <span class="number">26.26</span>.<span class="number">26.1</span></span><br><span class="line"><span class="number">128.0</span>.<span class="number">0.0</span>/<span class="number">1</span> dev tun0  scope link</span><br><span class="line"><span class="number">192.168</span>.<span class="number">58.0</span>/<span class="number">24</span> dev eth0  proto kernel  scope link  src <span class="number">192.168</span>.<span class="number">58.101</span></span><br></pre></td></tr></table></figure>
<p>但是，<code>ALL</code>或<code>BYPASS_CHN</code>模式下也会引发一个<strong>隐藏的坑</strong>：如果所有的流量都走tun设备（L3），tun2socks又从tunfd读出L3的包拆成L4的数据流转给ss-local，从ss-local出来准备发给远程shadowsocks服务器的流量（L4）又必然会到达tun设备(L3)，这样就直接<strong>死循环</strong>了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">tun&#35774;&#22791;(L3) =&#62; tun2socks(L3 -&#62; L4) =&#62; ss-local(L4) =&#62; tun&#35774;&#22791;(L3) =&#62; ...</span><br></pre></td></tr></table></figure>
<p>解决办法就是把远程shadowsocks服务器remotefd“保护”起来，让发到shadowsocks服务器流量不再走tun设备，而是直接通过物理网卡。在ss-local的<code>server_recv_cb</code>把remotefd传给<code>protect_socket</code>：</p>
<p>local.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server_recv_cb</span><span class="params">(EV_P_ ev_io *w, <span class="keyword">int</span> revents)</span></span><br><span class="line"></span>&#123;	...</span><br><span class="line">                <span class="keyword">if</span> (vpn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (protect_socket(remote-&gt;fd) == -<span class="number">1</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>和前面跨进程传递tunfd类似，不过这里IPC双方换成了ss-local和shadowsocks:vpn，ss-local通过unix domain socket方式和shadowsocks:vpn进程进行本地IPC（0x02提到过），利用<code>ancil_send_fd</code>传递remotefd给shadowsocks:vpn进程。</p>
<p>android.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">protect_socket</span><span class="params">(<span class="keyword">int</span> fd)</span></span><br><span class="line"></span>&#123;	...</span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> path[] = <span class="string">"/data/data/com.github.shadowsocks/protect_path"</span>;</span><br><span class="line">    ...</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, path, <span class="keyword">sizeof</span>(addr.sun_path) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) == -<span class="number">1</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">if</span> (ancil_send_fd(sock, fd)) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shadowsocks:vpn通过<code>socket.getAncillaryFileDescriptors</code>先拿到<code>FileDescriptor</code>，再通过<code>getInt.invoke</code>反射读出remotefd，用<code>vpnService.protect(fd)</code>保护起来，从而避免死循环。</p>
<p>ShadowsocksVpnThread.scala</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">PATH</span> = <span class="string">"/data/data/com.github.shadowsocks/protect_path"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(</span>) &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="keyword">val</span> socket = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">      pool.execute(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">          <span class="keyword">val</span> fds = socket.getAncillaryFileDescriptors</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (fds.nonEmpty) &#123;</span><br><span class="line">            <span class="keyword">val</span> fd = getInt.invoke(fds(<span class="number">0</span>)).asInstanceOf[<span class="type">Int</span>]</span><br><span class="line">            <span class="keyword">val</span> ret = vpnService.protect(fd)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Trick to close file decriptor</span></span><br><span class="line">            <span class="type">System</span>.jniclose(fd)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x05_pdnsd_u4E0Ess-tunnel"><a href="#0x05_pdnsd_u4E0Ess-tunnel" class="headerlink" title="0x05 pdnsd与ss-tunnel"></a>0x05 pdnsd与ss-tunnel</h1><p>ss-android还剩下2个native进程<strong>pdnsd</strong>和<strong>ss-tunnel</strong>没有介绍，<a href="http://members.home.nl/p.a.rombouts/pdnsd/index.html#aboutpdnsd" target="_blank" rel="external">pdnsd</a>是一个带永久缓存的dns代理服务器，而ss-tunnel主要用来实现本地端口转发，为什么前面VpnService设置了DNSServer还需要pdnsd+ss-tunnel呢，pdnsd+ss-tunnel可以不启动吗？</p>
<p>答案是：<strong>在设置udp转发的情况下可以</strong>。开启udp转发，做dns查询的udp包和其他udp包没有区别，都是通过ss-local转发给shadowsock服务器。我们重点看<strong>没有设置udp转发的情况</strong>。</p>
<p>shadowsocks:vpn启动tun2socks进程的时候，如果<code>config.isUdpDns</code>为false，会把<code>--dnsgw</code>也就是dns网关地址<code>26.26.26.1:8153</code>作为tun2socks的启动参数。</p>
<p>ShadowsocksVpnService.scala</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startVpn</span><span class="params">()</span>:</span> Int = &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (config.isUdpDns)</span><br><span class="line">    cmd += <span class="string">" --enable-udprelay"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cmd += <span class="string">" --dnsgw %s:8153"</span>.formatLocal(Locale.ENGLISH, PRIVATE_VLAN.formatLocal(Locale.ENGLISH, <span class="string">"1"</span>))</span><br></pre></td></tr></table></figure>
<p>tun2socks的<code>process_device_dns_packet</code>一旦发现去做dns解析的udp包，就会把udp包的ip和端口强行改成dnsgw的ip和端口<code>26.26.26.1:8153</code>，而<code>8153</code>端口是pdnsd进程监听的端口。</p>
<p>tun2socks.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_device_dns_packet</span> <span class="params">(uint8_t *data, <span class="keyword">int</span> data_len)</span></span><br><span class="line"></span>&#123; ...</span><br><span class="line">    <span class="comment">// do nothing if we don't have dnsgw</span></span><br><span class="line">    <span class="keyword">if</span> (!options.dnsgw) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">            <span class="comment">// to port 53 is considered a DNS packet</span></span><br><span class="line">            to_dns = udp_header.dest_port == hton16(<span class="number">53</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// from port 8153 is considered a DNS packet</span></span><br><span class="line">            from_dns = udp_header.source_port == dnsgw.ipv4.port;</span><br><span class="line">	...</span><br><span class="line">            <span class="comment">// modify DNS packet</span></span><br><span class="line">            <span class="keyword">if</span> (to_dns) &#123;</span><br><span class="line">            ...</span><br><span class="line">                <span class="comment">// build IP header</span></span><br><span class="line">                ipv4_header.destination_address = dnsgw.ipv4.ip;</span><br><span class="line">                ipv4_header.source_address = netif_ipaddr.ipv4;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// build UDP header</span></span><br><span class="line">                udp_header.dest_port = dnsgw.ipv4.port;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (from_dns) &#123;</span><br><span class="line">            ...                     </span><br><span class="line">                Connection * con = find_connection(udp_header.dest_port);                   </span><br><span class="line">                <span class="keyword">if</span> (con != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// build IP header</span></span><br><span class="line">                    ipv4_header.source_address = con-&gt;remote_addr.ipv4.ip;</span><br><span class="line">                    ipv4_header.destination_address = con-&gt;local_addr.ipv4.ip;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// build UDP header</span></span><br><span class="line">                    udp_header.source_port = con-&gt;remote_addr.ipv4.port;</span><br><span class="line"></span><br><span class="line">                    remove_connection(con);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>ss-tunnel会在本地起服务进程，然后同样转发dns查询的udp包，通过远程shadowsocks服务器给靠谱的dns服务器（例如<code>8.8.8.8:53</code>）。</p>
<p>系统默认的dns查询就是走udp的，我们知道ss-android成为全局代理后，tun2socks已经把所有做dns查询的udp包都转给了dnsgw（pdnsd），如果pdnsd+ss-tunnel不启动，那么显然所有的dns查询都会失败。</p>
<p>既然这么麻烦，那直接直接走udp转发不就好了吗，<strong>为什么还要用pdnsd+ss-tunnel呢？</strong></p>
<p>这是因为GFW会在境内骨干路由器上做入侵检测，一旦发现是查询google.com这种不和谐域名，就会伪造一个错误的ip地址给查询者。android系统dns查询默认走udp，但udp是不可靠的，会把最先返给自己的ip当作是目标ip，这个伪造的ip当然是无法正常访问的，这就是所谓的<strong>dns污染</strong>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#23458;&#25143;&#31471;&#36827;&#31243; &#60;=&#62; &#36335;&#30001;&#22120;dns &#60;=&#62; &#36816;&#33829;&#21830;dns &#60;=&#62; | GFW | &#60;=&#62; &#26681;dns</span><br></pre></td></tr></table></figure>
<p>而pdnsd主要用来提供一个无污染的dns，它不仅可以转发dns查询给上游dns服务器，修改TTL，提供缓存功能，尤为重要的是，pdnsd可以修改dns查询方式为tcp，<strong>从而避免dns污染</strong>。</p>
<hr>
<h1 id="0x06__u7ED3_u8BED"><a href="#0x06__u7ED3_u8BED" class="headerlink" title="0x06 结语"></a>0x06 结语</h1><p>ss-android最核心的功能几乎全是由c代码实现，依赖开源库也比较多，涉及到unix，内核，网络和安全等知识，加上ss-android的java层代码基本上是用scala写的，分析ss-android上层代码需要一定的scala功底，了解函数式编程等，这些都造成了ss-android学习的门槛。</p>
<p>本篇文章希望对正在学习ss-android的朋友有所帮助，由于时间有限，分析有误的地方也恳请指出。</p>
<p>最后附上本人的github：<a href="https://github.com/JLLK" target="_blank" rel="external">https://github.com/JLLK</a>。</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2016/02/28/shadowsocks-android-source-code-analysis/" target="_blank" rel="external">http://ct2wj.com/2016/02/28/shadowsocks-android-source-code-analysis/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u7B80_u4ECB"><a href="#0x00__u7B80_u4ECB" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p><a href="https://github.com/shadowsocks/shadowsocks-android">shadowsocks-android</a>(ss-android)是一款android上的科学上网软件，特点是无需root权限就能实现全局代理。作为一个shadowsocks重度使用者，本来想学习一下，但发现网上相关文章和资料还比较少，因此有了本篇文章，旨在分享自己对ss-android源码的一些理解。本文分析的源码基于ss-android的<a href="https://github.com/shadowsocks/shadowsocks-android/releases/tag/v2.9.11">2.9.11</a>版本。</p>
<hr>
<h1 id="0x01_ss-android_u8FDB_u7A0B_u6982_u8FF0"><a href="#0x01_ss-android_u8FDB_u7A0B_u6982_u8FF0" class="headerlink" title="0x01 ss-android进程概述"></a>0x01 ss-android进程概述</h1><p>本文先从整体上阐述ss-android进程之间的关系，然后从每个进程角度出发，结合源码分析ss-android科学上网的实现原理。ss-android启动时默认工作在vpn模式，创建2个java进程<strong>shadowsocks</strong>，<strong>shadowsocks:vpn</strong>以及4个native进程<strong>ss-local</strong>、<strong>pdnsd</strong>、<strong>ss-tunel</strong>、<strong>tun2socks</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u0_a124   <span class="number">14935</span> <span class="number">1857</span>  <span class="number">1058332</span> <span class="number">56560</span> SyS_epoll_ <span class="number">00000000</span> S com.github.shadowsocks:vpn</span><br><span class="line">u0_a124   <span class="number">16336</span> <span class="number">1857</span>  <span class="number">1235568</span> <span class="number">88380</span> SyS_epoll_ <span class="number">00000000</span> S com.github.shadowsocks</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u0_a124   <span class="number">20419</span> <span class="number">14935</span> <span class="number">3376</span>   <span class="number">1136</span>  SyS_epoll_ <span class="number">00000000</span> S /data/data/com.github.shadowsocks/ss-local</span><br><span class="line">u0_a124   <span class="number">20421</span> <span class="number">14935</span> <span class="number">7688</span>   <span class="number">804</span>   <span class="keyword">do</span>_sigtime <span class="number">00000000</span> S /data/data/com.github.shadowsocks/pdnsd</span><br><span class="line">u0_a124   <span class="number">20425</span> <span class="number">14935</span> <span class="number">3112</span>   <span class="number">940</span>   SyS_epoll_ <span class="number">00000000</span> S /data/data/com.github.shadowsocks/ss-tunnel</span><br><span class="line">u0_a124   <span class="number">20431</span> <span class="number">14935</span> <span class="number">3812</span>   <span class="number">1420</span>  SyS_epoll_ <span class="number">00000000</span> S /data/data/com.github.shadowsocks/tun2socks</span><br></pre></td></tr></table></figure>
<p>ss-android进程启动流程以及进程间通信关系图：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">shadowsocks =&#62; shadowsocks:vpn =&#62; ss-local =&#62; pdnsd =&#62; ss-tunnel =&#62; tun2socks</span><br></pre></td></tr></table></figure>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/ProcessOfShadowsocks.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="c" scheme="http://www.ct2wj.com/tags/c/"/>
    
      <category term="pdnsd" scheme="http://www.ct2wj.com/tags/pdnsd/"/>
    
      <category term="scala" scheme="http://www.ct2wj.com/tags/scala/"/>
    
      <category term="shadowsocks" scheme="http://www.ct2wj.com/tags/shadowsocks/"/>
    
      <category term="tun2socks" scheme="http://www.ct2wj.com/tags/tun2socks/"/>
    
      <category term="vpn" scheme="http://www.ct2wj.com/tags/vpn/"/>
    
      <category term="network" scheme="http://www.ct2wj.com/categories/network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一种按模块拆分dex和适机加载的方法]]></title>
    <link href="http://www.ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/"/>
    <id>http://www.ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/</id>
    <published>2016-02-09T10:59:53.000Z</published>
    <updated>2016-02-13T10:20:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一个功能成熟的app可能由多个业务平行的模块构成，由于业务是平行的，这些模块之间也应该没有耦合。本文希望在构建app时，每个平行业务线x对应的模块的class可以分解到dex(..x)中，这样做的好处是：</p>
<ul>
<li>maindex不会引入业务代码，可减少maindex体积</li>
<li>运行时，可延迟加载业务dex，减少app启动时间</li>
<li>能做一些有趣的工作，例如统计各个业务线模块启动时间</li>
</ul>
<p>本文在google multidex的基础上，通过应用<a href="https://github.com/JLLK/multidex-maker" target="_blank" rel="external">multidex-maker</a>,<a href="https://github.com/JLLK/multidex-installer" target="_blank" rel="external">multidex-installer</a>和<a href="https://github.com/JLLK/multidex-hook" target="_blank" rel="external">multidex-hook</a>，实现secondary dex的按模块拆分和适机延迟加载。文章最后给出了一个示例app：<a href="https://github.com/JLLK/multidex-sample" target="_blank" rel="external">multidex-sample</a>。<br><a id="more"></a></p>
<hr>
<h1 id="0x01_multidex-maker"><a href="#0x01_multidex-maker" class="headerlink" title="0x01 multidex-maker"></a>0x01 multidex-maker</h1><p><a href="https://github.com/JLLK/multidex-maker" target="_blank" rel="external">multidex-maker</a>(<a href="https://github.com/JLLK/multidex-maker" target="_blank" rel="external">https://github.com/JLLK/multidex-maker</a>)用来确保每个模块的class划分到自己的secondary dex。安装multidex-maker首先需要执行<code>./install.sh</code>。这一步会先编译multidex-maker，输出dx.jar。</p>
<p>请检查<code>~/Library/Android/sdk/platforms/android-${SDK_VERSION}/android.jar</code>中<code>SDK_VERSION</code>是否存在（默认是<code>17</code>)，编译完成后，会自动替换<code>~/Library/Android/sdk/build-tools/${BUILD_TOOL_VERSION}/lib</code>下的dx.jar，<code>BUILD_TOOL_VERSION</code>默认是<code>23.0.1</code>，如果build-tools中没有<code>23.0.1</code>请换成其他版本：</p>
<p>install.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SDK_VERSION=<span class="number">17</span>			<span class="comment"># change to your version</span></span><br><span class="line"></span><br><span class="line">BUILD_TOOL_VERSION=<span class="number">23.0</span>.<span class="number">1</span>	<span class="comment"># change to your version</span></span><br></pre></td></tr></table></figure>
<p>然后，在<code>build.gradle</code>中加上：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        tasks.matching &#123;</span><br><span class="line">            it.name.startsWith(<span class="string">"dex"</span>)</span><br><span class="line">        &#125;.each &#123; dx -&gt;</span><br><span class="line">            <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">                dx.additionalParameters = []</span><br><span class="line">            &#125;</span><br><span class="line">            dx.additionalParameters += <span class="string">"--main-dex-list=$projectDir/maindexlist.txt"</span>.toString()</span><br><span class="line">            dx.additionalParameters += <span class="string">"--secondary-dexes-list=$projectDir/secondarydexeslist.txt"</span>.toString()</span><br><span class="line">            dx.additionalParameters += <span class="string">"--minimal-main-dex"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>--secondary-dexes-list</code>是multidex-maker新加的编译参数，可以带上一个secondarydexeslist.txt文件，支持用<code>--secondary-dex-begin</code>和<code>--secondary-dex-end</code>把需要单独拆成dex的模块包名包含进来，例如示例app中的secondarydexeslist.txt：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span>    </span><br><span class="line"></span>com/github/jllk/multidex/sample/R</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span>    </span><br><span class="line"></span>scala/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span>	</span><br><span class="line"></span>com/github/jllk/multidex/sample/a/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span></span><br><span class="line"></span>com/github/jllk/multidex/sample/b/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span></span><br><span class="line"></span>com/github/jllk/multidex/sample/c/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span></span><br><span class="line"></span>com/github/jllk/multidex/sample/d/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>安装完成multidex-maker之后，在gradle build app时可以得到一个<strong>按模块拆分</strong>成多个secondary dex的app。</p>
<hr>
<h1 id="0x02_multidex-installer"><a href="#0x02_multidex-installer" class="headerlink" title="0x02 multidex-installer"></a>0x02 multidex-installer</h1><p>如果仅仅拆分了secondary dex，app应该还<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">不能运行</a>。一种解决方法是采用google multidex库的支持，选择在<code>Application.attachBaseContext</code>时调用<code>MultiDex.install(this)</code>。但这样会将secondary dexes一次性加载进来，失去了根据业务线实际情况加载dex的优势。</p>
<p><a href="https://github.com/JLLK/multidex-installer" target="_blank" rel="external">multidex-installer</a>(<a href="https://github.com/JLLK/multidex-installer" target="_blank" rel="external">https://github.com/JLLK/multidex-installer</a>)支持按dex索引来加载dex，提供了三种加载方法：<code>installAll</code>、<code>installOne</code>和<code>installRange</code>：</p>
<p>JLLKMultiDexInstaller.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Install all dexes in sourceApk</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installAll</span><span class="params">(Context context)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install one dex by index</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installOne</span><span class="params">(Context context, <span class="keyword">int</span> dexIndex)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Install dexes by range index</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installRange</span><span class="params">(Context context, <span class="keyword">int</span> startDexIndex, <span class="keyword">int</span> endDexIndex)</span></span></span><br></pre></td></tr></table></figure>
<p>使用multidex-installer需要在build.gradle中添加：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    compile <span class="string">"com.github.jllk:multidex-installer:0.0.4-beta@aar"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>attachBaseContext</code>，添加几行代码，让multidex-installer工作起来：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleApp</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">attachBaseContext</span>(</span>base: <span class="type">Context</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base)</span><br><span class="line">    <span class="type">JLLKMultiDexInstaller</span>.installOne(<span class="keyword">this</span>, <span class="number">2</span>) <span class="comment">// for R</span></span><br><span class="line">    <span class="type">JLLKMultiDexInstaller</span>.installRange(<span class="keyword">this</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// for scala</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x03_multidex-hook"><a href="#0x03_multidex-hook" class="headerlink" title="0x03 multidex-hook"></a>0x03 multidex-hook</h1><p>app启动时，在<code>Application.attachBaseContext</code>中加载dex也许不是最好的时机，假如用户没有使用模块A的功能，模块A对应的dex是没必要立刻加载的。更好的办法是在恰当的时机延迟加载dex，本文称为<strong>适机加载</strong>。</p>
<p>为此，本文提出了<a href="https://github.com/JLLK/multidex-hook" target="_blank" rel="external">multidex-hook</a>(<a href="https://github.com/JLLK/multidex-hook" target="_blank" rel="external">https://github.com/JLLK/multidex-hook</a>)，通过hook本应用进程的<code>Instrumentation</code>，在<code>Instrumentation.execStartActivity</code>方法被调用时，根据所启动模块的Activity的完全限定名来获得dex索引，再用multidex-installer加载相应dex。</p>
<p>JLLKInstrumentationProxy.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ActivityResult <span class="title">execStartActivityProxy</span><span class="params">(Context who, Intent intent, IExecStartActivityDelegate delegate)</span> </span>&#123;</span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent().getClassName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ResolveInfo resolveInfo = getContext().getPackageManager()</span><br><span class="line">                .resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">        <span class="keyword">if</span> (resolveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            className = resolveInfo.activityInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        className = intent.getComponent().getClassName();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"[execStartActivityProxy] "</span> + className);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install secondary dex by index.</span></span><br><span class="line">    <span class="keyword">int</span> dexIdx = JLLKMultiDexHook.getModuleDexIdx(className);</span><br><span class="line">    <span class="keyword">if</span> (dexIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        JLLKMultiDexInstaller.installOne(who, dexIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.execStartActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x04_multidex-sample"><a href="#0x04_multidex-sample" class="headerlink" title="0x04 multidex-sample"></a>0x04 multidex-sample</h1><p>本文的最后介绍示例app <a href="https://github.com/JLLK/multidex-sample" target="_blank" rel="external">multidex-sample</a>(<a href="https://github.com/JLLK/multidex-sample" target="_blank" rel="external">https://github.com/JLLK/multidex-sample</a>)，它同时用到了multidex-maker，multidex-installer和multidex-hook。构建完成后，multidex-sample输出的dex如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt; du -sh *<span class="class">.dex</span></span><br><span class="line"><span class="number">40</span>K	classes<span class="class">.dex</span></span><br><span class="line"><span class="number">4.0</span>K	classes2<span class="class">.dex</span></span><br><span class="line"><span class="number">7.0</span>M	classes3<span class="class">.dex</span></span><br><span class="line"><span class="number">1.7</span>M	classes4<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes5<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes6<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes7<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes8<span class="class">.dex</span></span><br><span class="line"><span class="number">28</span>K	classes9.dex</span><br></pre></td></tr></table></figure>
<p>其中，maindex（图左）仅包含multidex-installer和multidex-hook以及各模块X（a,b,c）的入口SampleActivityX，模块A（图右）仅包含业务相关的class：</p>
<table>
<thead>
<tr>
<th style="text-align:center">maindex</th>
<th style="text-align:center">Secondary dex: module A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/maindex.png?imageView2/2/w/300" alt=""></td>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/module-A.png?imageView2/2/w/320" alt=""></td>
</tr>
</tbody>
</table>
<p>以及完美的运行：</p>
<table>
<thead>
<tr>
<th style="text-align:center">MainActivity</th>
<th style="text-align:center">SampleActivityA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/MainActivity.png?imageView2/2/w/280" alt=""></td>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/ActivityA.png?imageView2/2/w/280" alt=""></td>
</tr>
</tbody>
</table>
<p>Done! ^_-</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/" target="_blank" rel="external">http://ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一个功能成熟的app可能由多个业务平行的模块构成，由于业务是平行的，这些模块之间也应该没有耦合。本文希望在构建app时，每个平行业务线x对应的模块的class可以分解到dex(..x)中，这样做的好处是：</p>
<ul>
<li>maindex不会引入业务代码，可减少maindex体积</li>
<li>运行时，可延迟加载业务dex，减少app启动时间</li>
<li>能做一些有趣的工作，例如统计各个业务线模块启动时间</li>
</ul>
<p>本文在google multidex的基础上，通过应用<a href="https://github.com/JLLK/multidex-maker">multidex-maker</a>,<a href="https://github.com/JLLK/multidex-installer">multidex-installer</a>和<a href="https://github.com/JLLK/multidex-hook">multidex-hook</a>，实现secondary dex的按模块拆分和适机延迟加载。文章最后给出了一个示例app：<a href="https://github.com/JLLK/multidex-sample">multidex-sample</a>。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="SecondaryDex" scheme="http://www.ct2wj.com/tags/SecondaryDex/"/>
    
      <category term="build system" scheme="http://www.ct2wj.com/tags/build-system/"/>
    
      <category term="dex" scheme="http://www.ct2wj.com/tags/dex/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[groovy动态特性浅析：从MOP到DSL]]></title>
    <link href="http://www.ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/"/>
    <id>http://www.ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/</id>
    <published>2016-01-16T13:04:21.000Z</published>
    <updated>2016-01-17T14:04:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>groovy作为一门基于jvm的动态类型语言，与java, scala等jvm静态类型语言的主要区别在哪呢，为什么gradle选择groovy实现自己的DSL? 它的优势在哪？</p>
</blockquote>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/614px-Groovy-logo.svg.png" alt=""></p>
<a id="more"></a>
<hr>
<h1 id="0x01__u9759_u6001_u548C_u52A8_u6001"><a href="#0x01__u9759_u6001_u548C_u52A8_u6001" class="headerlink" title="0x01 静态和动态"></a>0x01 静态和动态</h1><p>java是一门类型安全的语言，这种“安全”源于编译时编译器和运行时jvm对类型的检查。拥有编译时类型检查能力的语言，称为<code>静态类型</code>语言。静态语言能让类型错误尽量在编译时暴露，而非推迟到运行时，缺点是不利于快速编码和试错。与C++相比，java编译器做了许多工作，比如java泛型也是由编译器保证的。此外，由于在运行时jvm也会判断类型，所以java还是一种<code>强类型</code>的语言。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/languagesTypes.jpg" alt=""></p>
<p>groovy和java本质上没区别，甚至可以看做是java的一个强大的语法糖，它的特点之一是<code>动态类型</code>，groovyc并不会去检查类型，编译后的代码在执行过程中大量使用了反射，这样做的好处是：</p>
<ul>
<li>没有强制类型转换，不用和编译器较劲了^_-</li>
<li>调用方法时，不用立马关心方法的实现，让代码写起来非常灵活</li>
<li>方便支持元编程，能在运行时动态添加方法和属性，便于设计DSL</li>
</ul>
<p>我们可以比较这几段代码来感受一下java和groovy反射调用时的区别：</p>
<p>FleurWang.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FleurWang</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"hello wonderland!"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HolyHoleInJava.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolyHoleInJava</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jumpInto</span><span class="params">(Object somebody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = somebody.getClass().getMethod(<span class="string">"say"</span>);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object msg = method.invoke(somebody);</span><br><span class="line">            System.out.println(<span class="string">"someone jump into HolyHoleInJava, and say: "</span> + msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HolyHolyInGroovy.groovy</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HolyHoleInGroovy</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> jumpIntoGroovy(somebody) &#123;</span><br><span class="line">        println <span class="string">"someone jump into HolyHoleInGroovy, and say: $&#123;somebody.say()&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">girl = <span class="keyword">new</span> FleurWang()</span><br><span class="line">HolyHoleInJava.jumpInto(girl)</span><br><span class="line">HolyHoleInGroovy.jumpIntoGroovy(girl)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">someone jump <span class="keyword">into</span> HolyHoleInJava, <span class="keyword">and</span> <span class="command">say</span>: hello wonderland!</span><br><span class="line">someone jump <span class="keyword">into</span> HolyHoleInGroovy, <span class="keyword">and</span> <span class="command">say</span>: hello wonderland!</span><br></pre></td></tr></table></figure>
<p>当然groovy也有一些还不够好的地方，例如：</p>
<ul>
<li>失去了编译时的类型检查，作为弥补，需要引入大量的单元测试代码来保证代码质量。</li>
<li>相比java和scala混编，从java调用groovy代码很不方便。可以看下面代码感受一下~_~</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroovyShell shell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            shell.evaluate(<span class="keyword">new</span> File(<span class="string">"HolyHoleInGroovy.groovy"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过从groovy调java代码还是挺方便的，以及java各种优秀的开源库支持，再加上groovy自身的优点，这也许就是groovy成为gradle的DSL的原因。</p>
<hr>
<h1 id="0x02__u5143_u7F16_u7A0B_u548C_u5143_u5BF9_u8C61_u534F_u8BAE"><a href="#0x02__u5143_u7F16_u7A0B_u548C_u5143_u5BF9_u8C61_u534F_u8BAE" class="headerlink" title="0x02 元编程和元对象协议"></a>0x02 元编程和元对象协议</h1><p>我们知道java中的类加载后行为就确定了，而groovy中的类却是动态可变的，这是因为groovy支持元编程（虽然也能用其他手段改变，如native hook，运行时修改字节码等，但这里只讨论语言特性是否支持)。元编程(metaprogramming)是指代码在运行时可以动态改变自己的行为，元对象协议(MOP, Meta-Object Protocol)用来保证动态语言中元编程能力。在groovy中，元对象协议主要通过反射、元类(metaclass)、expandos等技术实现。</p>
<p>groovy世界中的类继承至java.lang.Object，并且实现了groovy.lang.GroovyObject接口，这个接口定义的invokeMethod, xxxProperty, xxxMetaClass让groovy对象具有动态扩展方法和属性的能力。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> groovy.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyObject</span> &#123;</span>	Object invokeMethod(String name, Object args); </span><br><span class="line">	Object getProperty(String property);	<span class="typename">void</span> setProperty(String property, Object newValue); </span><br><span class="line">	MetaClass getMetaClass();	<span class="typename">void</span> setMetaClass(MetaClass metaClass);￼￼￼￼￼￼￼￼&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们可以通过setMetaClass来改变FleurWang的行为。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">girl = <span class="keyword">new</span> FleurWang()</span><br><span class="line"></span><br><span class="line">girl.metaClass.laughAt = &#123; somebody -&gt;</span><br><span class="line">    System.out.println(<span class="string">"$&#123;delegate.class.getSimpleName()&#125; is laughing at $somebody"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">girl.laughAt(<span class="string">"tomchen"</span>)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">FleurWang <span class="keyword">is</span> laughing <span class="keyword">at</span> tomchen</span><br></pre></td></tr></table></figure>
<p>无论是java对象，还是groovy对象，每个对象的都有自己对应的MetaClass。groovy运行时生成进程唯一的MetaClassRegister对象，用于管理MetaClass和Class以及对象的映射关系。对于普通java对象而言，当它的方法被调用时，groovy会先去MetaClassRegister拿它的MetaClass看是否存在同名且同签名的方法。没有的话再去执行java对象本身的方法。因此，MetaClass的方法优先级高于原生方法。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/groovy2java.jpg" alt=""></p>
<p>对于groovy对象方法调用的容错会稍微多一点，groovy运行时会先检查对象是不是实现了GroovyInterceptable接口，是的话直接调用invokeMethod，否则会去MetaClass中找，如果没找到，那么会去Groovy对象本身找，还是没有的话，会去找Groovy对象否存在和方法同名的Closure类型字段closure，找到的话就直接closure()了。如果连这个字段都没有，也不会放弃，会尝试调用Groovy对象中的methodMissing方法，万一连这个也没有-_-，groovy还是会去做最后的努力，调用GroovyObject的invokeMethod()，没实现的话就会抛MissingMethodException。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/How%20Groovy%20handles%20method%20calls%20on%20a%20POGO.png" alt=""></p>
<hr>
<h1 id="0x03__u4E00_u4E2A_u7B80_u5355_u7684DSL"><a href="#0x03__u4E00_u4E2A_u7B80_u5355_u7684DSL" class="headerlink" title="0x03 一个简单的DSL"></a>0x03 一个简单的DSL</h1><p>利用groovy的动态特性和元编程能力来构造一个简单的DSL：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingCastle</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> result = <span class="keyword">new</span> StringWriter()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> members(closure) &#123;</span><br><span class="line">        result &lt;&lt; <span class="string">"tomchen&amp;fluer.wang's moving castle:\n"</span></span><br><span class="line">        closure.delegate = <span class="keyword">this</span></span><br><span class="line">        closure()</span><br><span class="line">        println result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> methodMissing(String name, args) &#123;</span><br><span class="line">        handle(name, args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> propertyMissing(String name) &#123;</span><br><span class="line">        Object[] emptyArray = []</span><br><span class="line">        handle(name, emptyArray)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> handle(String name, args) &#123;</span><br><span class="line">        level++</span><br><span class="line">        level.times &#123;</span><br><span class="line">            result &lt;&lt; <span class="string">" "</span></span><br><span class="line">        &#125;</span><br><span class="line">        result &lt;&lt; name.replaceAll(<span class="string">"_"</span>, <span class="string">" "</span>)</span><br><span class="line">        result &lt;&lt; printParameters(args)</span><br><span class="line">        result &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span> &amp;&amp; args[-<span class="number">1</span>] <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">            <span class="keyword">def</span> theClosure = args[-<span class="number">1</span>]</span><br><span class="line">            theClosure.delegate = <span class="keyword">this</span></span><br><span class="line">            theClosure()</span><br><span class="line">        &#125;</span><br><span class="line">        level--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> printParameters(args) &#123;</span><br><span class="line">        <span class="keyword">def</span> values = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            values += <span class="string">" ["</span></span><br><span class="line">            <span class="keyword">def</span> count = <span class="number">0</span></span><br><span class="line">            args[<span class="number">0</span>].each &#123; key, value -&gt;</span><br><span class="line">                count++</span><br><span class="line">                values += (count &gt; <span class="number">1</span> ? " " : <span class="string">""</span>)</span><br><span class="line">                values += <span class="string">"$&#123;key&#125;: $&#123;value&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">            values += <span class="string">"]"</span></span><br><span class="line">        &#125;</span><br><span class="line">        values</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">castle = <span class="keyword">new</span> MovingCastle()</span><br><span class="line">castle.members &#123;</span><br><span class="line">    tomchen &#123;</span><br><span class="line">        about(<span class="string">github:</span> <span class="string">"https://github.com/jllk"</span>)</span><br><span class="line">        lauguage &#123;</span><br><span class="line">            java</span><br><span class="line">            scala</span><br><span class="line">            c</span><br><span class="line">            golang</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fluerWang &#123;</span><br><span class="line">        about(<span class="string">github:</span> <span class="string">"https://github.com/fleurWang"</span>)</span><br><span class="line">        lauguage &#123;</span><br><span class="line">            javascript</span><br><span class="line">            html</span><br><span class="line">            css</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">tomchen&amp;fluer.wang's moving castle:</span><br><span class="line"> tomchen</span><br><span class="line">  <span class="keyword">about</span> [github: https:<span class="comment">//github.com/jllk]</span></span><br><span class="line">  lauguage</span><br><span class="line">   java</span><br><span class="line">   <span class="keyword">scala</span></span><br><span class="line">   c</span><br><span class="line">   golang</span><br><span class="line"> fluerWang</span><br><span class="line">  <span class="keyword">about</span> [github: https:<span class="comment">//github.com/fleurWang]</span></span><br><span class="line">  lauguage</span><br><span class="line">   javascript</span><br><span class="line">   html</span><br><span class="line">   css</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h4><p>[1]. <a href="https://pragprog.com/book/vslg2/programming-groovy-2" target="_blank" rel="external">programming Groovy 2</a></p>
<p>[2]. <a href="http://www.amazon.com/Groovy-Domain-Specific-Languages-Fergal-Dearle/dp/1849695407/ref=sr_1_1?ie=UTF8&amp;qid=1452654163&amp;sr=8-1&amp;keywords=Groovy_for_Domain-Specific_Languages" target="_blank" rel="external">Groovy for Domain-Specific Languages - Second Edition</a></p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/" target="_blank" rel="external">http://ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>groovy作为一门基于jvm的动态类型语言，与java, scala等jvm静态类型语言的主要区别在哪呢，为什么gradle选择groovy实现自己的DSL? 它的优势在哪？</p>
</blockquote>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/614px-Groovy-logo.svg.png" alt=""></p>]]>
    
    </summary>
    
      <category term="DSL" scheme="http://www.ct2wj.com/tags/DSL/"/>
    
      <category term="MOP" scheme="http://www.ct2wj.com/tags/MOP/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="groovy" scheme="http://www.ct2wj.com/tags/groovy/"/>
    
      <category term="metaprograming" scheme="http://www.ct2wj.com/tags/metaprograming/"/>
    
      <category term="groovy" scheme="http://www.ct2wj.com/categories/groovy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android compile tasks中dex过程源码情景分析]]></title>
    <link href="http://www.ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/"/>
    <id>http://www.ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/</id>
    <published>2015-12-31T09:40:37.000Z</published>
    <updated>2016-01-16T13:33:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p><a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>中我们知道main dex的class可以由maindexlist.txt指定，<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/" target="_blank" rel="external">Android MultiDex机制杂谈</a>中我们分析了google MultiDex机制中Secondary dex的install过程，那么，我们的app在android gradle build过程中，.dex文件是怎么创建的呢？ 再者，Secondary dex中的class是按什么顺序分配到不同dex中的呢？</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="0x01_android_build_system_u6982_u8FF0"><a href="#0x01_android_build_system_u6982_u8FF0" class="headerlink" title="0x01 android build system概述"></a>0x01 android build system概述</h1><p>为了解答上面的两个问题，本文将进一步分析android build system源码。<br><a href="http://developer.android.com/intl/zh-cn/sdk/installing/studio-build.html" target="_blank" rel="external">android build system</a>是google提供的一组用来构建、运行、测试和打包我们app的工具集，包含了<code>aapt</code>、<code>aidl</code>、<code>javac</code>、<code>dex</code>、<code>apkbuilder</code>、<code>Jarsigner</code>、<code>zipalign</code>等工具。在我们构建app时，build进程会去按一定顺序调用上述工具来生成相应文件，而最终的输出将会是一个完整的可安装的.apk文件，构建流程如下：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/build.png" alt=""></p>
<p>构建系统先从product flavors, build types和dependencies中合并资源，如果不同目录下有重名资源，将按以下优先级进行覆盖：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &gt; build types &gt; product flavors &gt; main <span class="keyword">source</span> directory</span><br></pre></td></tr></table></figure>
<ol>
<li>aapt编译应用的资源文件（如AndroidManifest.xml），输出R.java文件</li>
<li>aidl把.aidl文件转换为对应的java interface文件</li>
<li>javac编译所有.java文件，输出.class文件</li>
<li>dex工具把上面生成的.class文件转换为.dex文件</li>
<li>apkbuilder把所有没编译的资源（如图片），编译过的资源和dex文件打包输出为.apk文件</li>
<li>在release模式下，用zipalign工具对.apk进行对齐处理，以减少运行时内存占用</li>
</ol>
<p>本文重点对<code>第4步</code>中.class经过dex到.dex过程源码进行分析。</p>
<hr>
<h1 id="0x02_android_compile_tasks_u5206_u6790"><a href="#0x02_android_compile_tasks_u5206_u6790" class="headerlink" title="0x02 android compile tasks分析"></a>0x02 android compile tasks分析</h1><p>为了更好地分析.dex的产生过程，本文设定情景如下：</p>
<blockquote>
<p>构建工具为gradle，采用android plugin <code>&#39;com.android.application&#39;</code>，method数超过65535，需要进行multidex，并且指定了<code>multiDexEnabled = true</code>。</p>
</blockquote>
<p>在shell终端cd到project根目录，输入： </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="title">gradle</span> assemble</span><br></pre></td></tr></table></figure>
<p>gradle进程会启动，在dex之前，进程控制流将进入VariantManager. createTasksForVariantData。添加完assemble task依赖后，会去调用taskManager.createTasksForVariantData(tasks, variantData)。由于android plugin为’com.android.application’，这里的taskManager是ApplicationTaskManager。</p>
<p>com/android/build/gradle/internal/VariantManager.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create tasks for the specified variantData.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span><br><span class="line">        <span class="keyword">final</span> TaskFactory tasks,</span><br><span class="line">        <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add dependency of assemble task on assemble build type task.</span></span><br><span class="line">    tasks.named(<span class="string">"assemble"</span>, <span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            BuildTypeData buildTypeData = buildTypes.get(</span><br><span class="line">                            variantData.getVariantConfiguration().getBuildType().getName());</span><br><span class="line">            task.dependsOn(buildTypeData.getAssembleTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">        taskManager.createTasksForVariantData(tasks, variantData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationTaskManager.createTasksForVariantData()会通过ThreadRecorder.get().record()第二个callback参数的类型为Recorder.Block&lt;Void&gt;，在call回调中调用父类TaskManager.createPostCompilationTasks。ThreadRecorder可以记录该任务的在当前线程的执行时间，并且保证task之间是串行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * TaskManager for creating tasks in an Android application project.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTaskManager</span> <span class="keyword">extends</span> <span class="title">TaskManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span><br><span class="line">            @NonNull <span class="keyword">final</span> TaskFactory tasks,</span><br><span class="line">            @NonNull <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// Add a compile task</span></span><br><span class="line">        ThreadRecorder.get().record(ExecutionType.APP_TASK_MANAGER_CREATE_COMPILE_TASK,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        AndroidTask&lt;JavaCompile&gt; javacTask = createJavacTask(tasks, variantScope);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (variantData.getVariantConfiguration().getUseJack()) &#123;</span><br><span class="line">                            createJackTask(tasks, variantScope);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            setJavaCompilerTask(javacTask, tasks, variantScope);</span><br><span class="line">                            createJarTask(tasks, variantScope);</span><br><span class="line">                            createPostCompilationTasks(tasks, variantScope);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskManager.createPostCompilationTasks方法，这个方法比较长，我们分段来分析。</p>
<p>首先从config得到isMultiDexEnabled，isMultiDexEnabled，isLegacyMultiDexMode，由于已经假设当前为需要MultiDex的场景，因此isMultiDexEnabled为true。若isMinifyEnabled也为true，则说明输入jar包需要进行混淆，本场景先不考虑。</p>
<p>TaskManager.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates the post-compilation tasks for the given Variant.</span><br><span class="line"> *</span><br><span class="line"> * These tasks create the dex file from the .class files, plus optional intermediary steps like</span><br><span class="line"> * proguard and jacoco</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPostCompilationTasks</span><span class="params">(TaskFactory tasks, @NonNull <span class="keyword">final</span> VariantScope variantScope)</span> </span>&#123;</span><br><span class="line">    checkNotNull(variantScope.getJavacTask());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();</span><br><span class="line">    <span class="keyword">final</span> GradleVariantConfiguration config = variantData.getVariantConfiguration();</span><br><span class="line"></span><br><span class="line">    TransformManager transformManager = variantScope.getTransformManager();</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">boolean</span> isMinifyEnabled = config.isMinifyEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> isMultiDexEnabled = config.isMultiDexEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> isLegacyMultiDexMode = config.isLegacyMultiDexMode();</span><br><span class="line"></span><br><span class="line">    AndroidConfig extension = variantScope.getGlobalScope().getExtension();</span><br></pre></td></tr></table></figure>
<p>在支持MultiDex的场景中，先创建manifestKeepListTask，将依赖设置为ManifestProcessorTask，这些android compile task由AndroidTask&lt;TransformTask&gt;类型来描述。</p>
<p>接着创建multiDexClassListTask，依赖manifestKeepListTask。这两个tasks用来输出maindexlist.txt，其中包含了MainDex中必须的class，可参见<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ----- Multi-Dex support</span></span><br><span class="line"></span><br><span class="line">AndroidTask&lt;TransformTask&gt; multiDexClassListTask = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// non Library test are running as native multi-dex</span></span><br><span class="line"><span class="keyword">if</span> (isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (AndroidGradleOptions.useNewShrinker(project)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"New shrinker + multidex not supported yet."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="comment">// create a transform to jar the inputs into a single jar.</span></span><br><span class="line">    <span class="keyword">if</span> (!isMinifyEnabled) &#123;</span><br><span class="line">        <span class="comment">// merge the classes only, no need to package the resources since they are</span></span><br><span class="line">        <span class="comment">// not used during the computation.</span></span><br><span class="line">        JarMergingTransform jarMergingTransform = <span class="keyword">new</span> JarMergingTransform(</span><br><span class="line">                TransformManager.SCOPE_FULL_PROJECT);</span><br><span class="line">        transformManager.addTransform(tasks, variantScope, jarMergingTransform);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="comment">// Create a task to collect the list of manifest entry points which are</span></span><br><span class="line">    <span class="comment">// needed in the primary dex</span></span><br><span class="line">    AndroidTask&lt;CreateManifestKeepList&gt; manifestKeepListTask = androidTasks.create(tasks,</span><br><span class="line">            <span class="keyword">new</span> CreateManifestKeepList.ConfigAction(variantScope));</span><br><span class="line">    manifestKeepListTask.dependsOn(tasks,</span><br><span class="line">            variantData.getOutputs().get(<span class="number">0</span>).getScope().getManifestProcessorTask());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="comment">// create the transform that's going to take the code and the proguard keep list</span></span><br><span class="line">    <span class="comment">// from above and compute the main class list.</span></span><br><span class="line">    MultiDexTransform multiDexTransform = <span class="keyword">new</span> MultiDexTransform(</span><br><span class="line">            variantScope.getManifestKeepListFile(),</span><br><span class="line">            variantScope,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">    multiDexClassListTask = transformManager.addTransform(</span><br><span class="line">            tasks, variantScope, multiDexTransform);</span><br><span class="line">    multiDexClassListTask.dependsOn(tasks, manifestKeepListTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后创建dexTask，这个用来把.class文件转为.dex的task，它依赖multiDexClassListTask。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// create dex transform</span></span><br><span class="line">    DexTransform dexTransform = <span class="keyword">new</span> DexTransform(</span><br><span class="line">            extension.getDexOptions(),</span><br><span class="line">            config.getBuildType().isDebuggable(),</span><br><span class="line">            isMultiDexEnabled,</span><br><span class="line">            isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode ? variantScope.getMainDexListFile() : <span class="keyword">null</span>,</span><br><span class="line">            variantScope.getPreDexOutputDir(),</span><br><span class="line">            variantScope.getGlobalScope().getAndroidBuilder(),</span><br><span class="line">            getLogger());</span><br><span class="line">    AndroidTask&lt;TransformTask&gt; dexTask = transformManager.addTransform(</span><br><span class="line">            tasks, variantScope, dexTransform);</span><br><span class="line">    <span class="comment">// need to manually make dex task depend on MultiDexTransform since there's no stream</span></span><br><span class="line">    <span class="comment">// consumption making this automatic</span></span><br><span class="line">    dexTask.optionalDependsOn(tasks, multiDexClassListTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task执行时，gradle引擎会去调用含有@TaskAction注解的方法，TransformTask类拥有Transfrom类型字段，其transform方法被标记为@TaskAction。同样通过ThreadRecorder.get().record中回调call()，执行transform.transform()</p>
<p>TransformTask.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A task running a transform.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ParallelizableTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTask</span> <span class="keyword">extends</span> <span class="title">StreamBasedTask</span> <span class="keyword">implements</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform transform;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">final</span> IncrementalTaskInputs incrementalTaskInputs)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line">		 ...</span><br><span class="line">        ThreadRecorder.get().record(ExecutionType.TASK_TRANSFORM,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        transform.transform(</span><br><span class="line">                                TransformTask.<span class="keyword">this</span>,</span><br><span class="line">                                consumedInputs.getValue(),</span><br><span class="line">                                referencedInputs.getValue(),</span><br><span class="line">                                outputStream != <span class="keyword">null</span> ? outputStream.asOutput() : <span class="keyword">null</span>,</span><br><span class="line">                                isIncremental.getValue());</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"project"</span>, getProject().getName()),</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"transform"</span>, transform.getName()),</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"incremental"</span>, Boolean.toString(transform.isIncremental())));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述android compile tasks关系可以用下图描述：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/multi-dex-task.jpg" alt=""></p>
<p>从gradle task角度上看，这些task都属于TransformTask（继承至DefaultTask），它们区别仅在于transform字段。DexTask是本文主要关心的task，下面分析这个task执行过程中都做了什么。</p>
<hr>
<h1 id="0x03_DexTask_u6267_u884C_u8FC7_u7A0B_u5206_u6790"><a href="#0x03_DexTask_u6267_u884C_u8FC7_u7A0B_u5206_u6790" class="headerlink" title="0x03 DexTask执行过程分析"></a>0x03 DexTask执行过程分析</h1><p>android build system中dex过程发生在DexTask，DexTask关联的Transform是DexTransform。</p>
<p>当DexTransform.transfrom方法被调用时，会先创建并初始化main目录作为输出dex的目录，然后调用androidBuilder.convertByteCode方法进行.class到.dex的转换，此时jarInputs为classes.jar，directoryInputs长度为空，传递的boolean类型的multiDex参数来自build.gralde文件中在<code>defaultConfig</code>对<code>multiDexEnabled = true</code>的设置。</p>
<p>DexTransform.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(</span><br><span class="line">        @NonNull Context context,</span><br><span class="line">        @NonNull Collection&lt;TransformInput&gt; inputs,</span><br><span class="line">        @NonNull Collection&lt;TransformInput&gt; referencedInputs,</span><br><span class="line">        @Nullable TransformOutputProvider outputProvider,</span><br><span class="line">        <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> TransformException, IOException, InterruptedException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// Gather a full list of all inputs.</span></span><br><span class="line">    List&lt;JarInput&gt; jarInputs = Lists.newArrayList();</span><br><span class="line">    List&lt;DirectoryInput&gt; directoryInputs = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (TransformInput input : inputs) &#123;</span><br><span class="line">        jarInputs.addAll(input.getJarInputs());</span><br><span class="line">        directoryInputs.addAll(input.getDirectoryInputs());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// if only one scope or no per-scope dexing, just do a single pass that</span></span><br><span class="line">        <span class="comment">// runs dx on everything.</span></span><br><span class="line">        <span class="keyword">if</span> ((jarInputs.size() + directoryInputs.size()) == <span class="number">1</span> || !dexOptions.getPreDexLibraries()) &#123;</span><br><span class="line">            File outputDir = outputProvider.getContentLocation(<span class="string">"main"</span>,</span><br><span class="line">                    getOutputTypes(), getScopes(),</span><br><span class="line">                    Format.DIRECTORY);</span><br><span class="line">            FileUtils.mkdirs(outputDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first delete the output folder where the final dex file(s) will be.</span></span><br><span class="line">            FileUtils.emptyFolder(outputDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gather the inputs. This mode is always non incremental, so just</span></span><br><span class="line">            <span class="comment">// gather the top level folders/jars</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;File&gt; inputFiles = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (JarInput jarInput : jarInputs) &#123;</span><br><span class="line">                inputFiles.add(jarInput.getFile());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DirectoryInput directoryInput : directoryInputs) &#123;</span><br><span class="line">                inputFiles.add(directoryInput.getFile());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            androidBuilder.convertByteCode(</span><br><span class="line">                    inputFiles,</span><br><span class="line">                    outputDir,</span><br><span class="line">                    multiDex,</span><br><span class="line">                    mainDexListFile,</span><br><span class="line">                    dexOptions,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">true</span>,</span><br><span class="line">                    <span class="keyword">new</span> LoggedProcessOutputHandler(logger));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>为了把输入的.class转换为.dex，AndroidBuilder.convertByteCode会另起进程去做dex，实际上是在新进程中exec dex工具，接下来我们进入dex源码，看看到底发生了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertByteCode</span><span class="params">(</span><br><span class="line">         @NonNull Collection&lt;File&gt; inputs,</span><br><span class="line">         @NonNull File outDexFolder,</span><br><span class="line">                  <span class="keyword">boolean</span> multidex,</span><br><span class="line">         @Nullable File mainDexList,</span><br><span class="line">         @NonNull DexOptions dexOptions,</span><br><span class="line">         @Nullable List&lt;String&gt; additionalParameters,</span><br><span class="line">         <span class="keyword">boolean</span> incremental,</span><br><span class="line">         <span class="keyword">boolean</span> optimize,</span><br><span class="line">         @NonNull ProcessOutputHandler processOutputHandler)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, InterruptedException, ProcessException </span>&#123;</span><br><span class="line">...</span><br><span class="line">     BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">     DexProcessBuilder builder = <span class="keyword">new</span> DexProcessBuilder(outDexFolder);</span><br><span class="line"></span><br><span class="line">     builder.setVerbose(mVerboseExec)</span><br><span class="line">             .setIncremental(incremental)</span><br><span class="line">             .setNoOptimize(!optimize)</span><br><span class="line">             .setMultiDex(multidex)</span><br><span class="line">             .setMainDexList(mainDexList)</span><br><span class="line">             .addInputs(verifiedInputs.build());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (additionalParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">         builder.additionalParameters(additionalParameters);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     JavaProcessInfo javaProcessInfo = builder.build(buildToolInfo, dexOptions);</span><br><span class="line"></span><br><span class="line">     ProcessResult result = mJavaProcessExecutor.execute(javaProcessInfo, processOutputHandler);</span><br><span class="line">     result.rethrowFailure().assertNormalExitValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x04_dex_u8FC7_u7A0B_u5206_u6790"><a href="#0x04_dex_u8FC7_u7A0B_u5206_u6790" class="headerlink" title="0x04 dex过程分析"></a>0x04 dex过程分析</h1><p>android 5.0中dex工具源码路径是dalvik/dx/src/com/android/dx，入口类是com.android.dx.command.Main，当解析到参数–dex时，转入com.android.dx.command.dexer.Main.main()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">             <span class="keyword">if</span> (arg.equals(<span class="string">"--dex"</span>)) &#123;</span><br><span class="line">                 com.android.dx.command.dexer.Main.main(without(args, i));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">"--dump"</span>)) &#123;</span><br><span class="line">                 com.android.dx.command.dump.Main.main(without(args, i));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>main会调用com.android.dx.command.dexer.Main.run()，此时args.multiDex为true，直接进入runMultiDex</p>
<p>com.android.dx.command.dexer.Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(Arguments arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.multiDex) &#123;</span><br><span class="line">            <span class="keyword">return</span> runMultiDex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> runMonoDex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeOutput(humanOutRaw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runMultiDex会调用processAllFiles，第一行代码调用createDexFile()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processAllFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     createDexFile();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>createDexFile先检查outputDex(: DexFile)字段是否为空，不为空则调用writeDex()把该dex的byte[]添加到dexOutputArrays(: List&lt;byte[]&gt;)。</p>
<p>writeDex()具体是通过outputDex.toDex(humanOutWriter, args.verboseDump)得到dex的byte[]。java中数组的下标是int类型，长度为32bits，因此一个dex文件最大理论是4G，但实际由于method, field数等限制，正常最大也就10M左右。</p>
<p>然后还会为outputDex字段新建一个DexFile对象，表示当前dex文件已经处理完毕，可以开始处理新的dex文件了。这里假设进程第一次执行createDexFile，因此outputDex为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDexFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputDex != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dexOutputArrays.add(writeDex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputDex = <span class="keyword">new</span> DexFile(args.dexOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.dumpWidth != <span class="number">0</span>) &#123;</span><br><span class="line">        outputDex.setDumpWidth(args.dumpWidth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后processAllFiles会根据args中numThreads来决定是否需要创建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.numThreads &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    threadPool = Executors.newFixedThreadPool(args.numThreads);</span><br><span class="line">    parallelProcessorFutures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Void&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来判断args.mainDexListFile，不为空说明指定了maindexlist.txt文件，这里假设不为空，filesNames数组是{‘path/way/to/classes.jar’}，长度为1。方法在for循环中调用processOne()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   anyFilesProcessed = <span class="keyword">false</span>;</span><br><span class="line">   String[] fileNames = args.fileNames;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (args.mainDexListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// with --main-dex-list</span></span><br><span class="line">           FileNameFilter mainPassFilter = args.strictNameCheck ? <span class="keyword">new</span> MainDexListFilter() :</span><br><span class="line">               <span class="keyword">new</span> BestEffortMainDexListFilter();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// forced in main dex</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">               processOne(fileNames[i], mainPassFilter);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>processOne调用ClassPathOpener.process处理输入的classes.jar。ClassPathOpener会遍历classes.jar中的每个ZipEntry，读出byte[]，对每个ZipEntry在回调processFileBytes中调用Main.processFileBytes方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Processes one pathname element.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> pathname &#123;<span class="doctag">@code</span> non-null;&#125; the pathname to process. May</span><br><span class="line"> * be the path of a class file, a jar file, or a directory</span><br><span class="line"> * containing class files.</span><br><span class="line"> * <span class="doctag">@param</span> filter &#123;<span class="doctag">@code</span> non-null;&#125; A filter for excluding files.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processOne</span><span class="params">(String pathname, FileNameFilter filter)</span> </span>&#123;</span><br><span class="line">    ClassPathOpener opener;</span><br><span class="line"></span><br><span class="line">    opener = <span class="keyword">new</span> ClassPathOpener(pathname, <span class="keyword">false</span>, filter,</span><br><span class="line">            <span class="keyword">new</span> ClassPathOpener.Consumer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Main.processFileBytes(name, lastModified, bytes);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.numThreads &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        parallelProcessorFutures.add(threadPool.submit(<span class="keyword">new</span> ParallelProcessor(opener)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (opener.process()) &#123;</span><br><span class="line">            anyFilesProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.processFileBytes把输入的bytes分为三类：</p>
<ul>
<li>.class文件</li>
<li>.dex文件</li>
<li>资源文件</li>
</ul>
<p>如果输入是.dex或资源文件，则把bytes分别写入libraryDexBuffers字段或outputResources字段，此时输入name(: String)为.class。当发现是class，则进一步调用processClass处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * Processes one file, which may be either a class or a resource.</span><br><span class="line">  *</span><br><span class="line">  * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file</span><br><span class="line">  * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">  * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> isClass = name.endsWith(<span class="string">".class"</span>);</span><br><span class="line">     <span class="keyword">boolean</span> isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME);</span><br><span class="line">     <span class="keyword">boolean</span> keepResources = (outputResources != <span class="keyword">null</span>);</span><br><span class="line">... </span><br><span class="line">     String fixedName = fixPath(name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (isClass) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (keepResources &amp;&amp; args.keepClassesInJar) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (outputResources) &#123;</span><br><span class="line">                 outputResources.put(fixedName, bytes);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (lastModified &lt; minimumFileAge) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> processClass(fixedName, bytes);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClassesDex) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (libraryDexBuffers) &#123;</span><br><span class="line">             libraryDexBuffers.add(bytes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (outputResources) &#123;</span><br><span class="line">             outputResources.put(fixedName, bytes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>processClass方法主要做了以下几件事：</p>
<ol>
<li>为传入的class创建DirectClassFile对象，对应.class字节码文件</li>
<li>得到已经生成的dex的numMethodIds，numFieldIds</li>
<li>得到新Class的constantPoolSize，计算maxMethodIdsInDex = numMethodIds + constantPoolSize + 新Class的方法数 + 2个预留method， 计算maxFieldIdsInDex = numFieldIds + constantPoolSize + 新Class的字段数 + 9个预留field</li>
<li>一旦发现maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex 或者 maxFieldIdsInDex &gt; args.maxNumber OfIdxPerDex，说明当前dex已经满了，调用createDexFile创建新dex来容纳该Class</li>
<li>否则，通过CfTranslator.translate方法将输入的DirectClassFile对象，得到ClassDefItem，添加到outputDex(: DexFile)</li>
</ol>
<p>由此可以看出：</p>
<blockquote>
<p>secondray dex中的class是根据classes.jar中ZipEntry的遍历顺序添加的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * Processes one classfile.</span><br><span class="line">  *</span><br><span class="line">  * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file, clipped such that it</span><br><span class="line">  * &lt;i&gt;should&lt;/i&gt; correspond to the name of the class it contains</span><br><span class="line">  * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">  * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processClass</span><span class="params">(String name, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (! args.coreLibrary) &#123;</span><br><span class="line">         checkClassName(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     DirectClassFile cf =</span><br><span class="line">         <span class="keyword">new</span> DirectClassFile(bytes, name, args.cfOptions.strictNameCheck);</span><br><span class="line"></span><br><span class="line">     cf.setAttributeFactory(StdAttributeFactory.THE_ONE);</span><br><span class="line">     cf.getMagic();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> numMethodIds = outputDex.getMethodIds().items().size();</span><br><span class="line">     <span class="keyword">int</span> numFieldIds = outputDex.getFieldIds().items().size();</span><br><span class="line">     <span class="keyword">int</span> constantPoolSize = cf.getConstantPool().size();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> maxMethodIdsInDex = numMethodIds + constantPoolSize + cf.getMethods().size() +</span><br><span class="line">             MAX_METHOD_ADDED_DURING_DEX_CREATION;</span><br><span class="line">     <span class="keyword">int</span> maxFieldIdsInDex = numFieldIds + constantPoolSize + cf.getFields().size() +</span><br><span class="line">             MAX_FIELD_ADDED_DURING_DEX_CREATION;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (args.multiDex</span><br><span class="line">         <span class="comment">// Never switch to the next dex if current dex is already empty</span></span><br><span class="line">         &amp;&amp; (outputDex.getClassDefs().items().size() &gt; <span class="number">0</span>)</span><br><span class="line">         &amp;&amp; ((maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex) ||</span><br><span class="line">             (maxFieldIdsInDex &gt; args.maxNumberOfIdxPerDex))) &#123;</span><br><span class="line">         DexFile completeDex = outputDex;</span><br><span class="line">         createDexFile();</span><br><span class="line">         <span class="keyword">assert</span>  (completeDex.getMethodIds().items().size() &lt;= numMethodIds +</span><br><span class="line">                 MAX_METHOD_ADDED_DURING_DEX_CREATION) &amp;&amp;</span><br><span class="line">                 (completeDex.getFieldIds().items().size() &lt;= numFieldIds +</span><br><span class="line">                 MAX_FIELD_ADDED_DURING_DEX_CREATION);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ClassDefItem clazz =</span><br><span class="line">             CfTranslator.translate(cf, bytes, args.cfOptions, args.dexOptions, outputDex);</span><br><span class="line">         <span class="keyword">synchronized</span> (outputDex) &#123;</span><br><span class="line">             outputDex.add(clazz);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (ParseException ex) &#123;</span><br><span class="line">         DxConsole.err.println(<span class="string">"\ntrouble processing:"</span>);</span><br><span class="line">         <span class="keyword">if</span> (args.debug) &#123;</span><br><span class="line">             ex.printStackTrace(DxConsole.err);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ex.printContext(DxConsole.err);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     errors.incrementAndGet();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>再回到processAllFiles，前面假设指定了maindexlist，如果minialMainDex也为true的话，会立即创建新的DexFile，保证这个main dex中只包含maindexlist里的类，如何指定可以参考<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道 0x05</a>。前面没有过滤掉的class都会放入到secondary dex。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexOutputArrays.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">"Too many classes in "</span> + Arguments.MAIN_DEX_LIST_OPTION</span><br><span class="line">                    + <span class="string">", main dex capacity exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.minimalMainDex) &#123;</span><br><span class="line">            <span class="comment">// start second pass directly in a secondary dex file.</span></span><br><span class="line">            createDexFile();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remaining files</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">            processOne(fileNames[i], <span class="keyword">new</span> NotFilter(mainPassFilter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// without --main-dex-list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">            processOne(fileNames[i], ClassPathOpener.acceptAll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (StopProcessing ex) &#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Ignore it and just let the error reporting do</span><br><span class="line">     * their things.</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在runMultiDex的最后，dex文件将以classes(..N).dex的形式输出在由args.outName指定的目录之下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runMultiDex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.outName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File outDir = <span class="keyword">new</span> File(args.outName);</span><br><span class="line">            <span class="keyword">assert</span> outDir.isDirectory();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dexOutputArrays.size(); i++) &#123;</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(outDir, getDexFileName(i)));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.write(dexOutputArrays.get(i));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    closeOutput(out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x05__u7ED3_u8BBA"><a href="#0x05__u7ED3_u8BBA" class="headerlink" title="0x05 结论"></a>0x05 结论</h1><p>通过对android build system中android plugin tasks和dx工具源码的分析，我们可以得出如下结论：</p>
<ul>
<li><p>.dex文件本质上是.class文件经过com.android.dx.dex.file.DexFile.toDex方法转换得到</p>
</li>
<li><p>Secondary dex是在指定了<code>multiDexEnabled = true且MainDex满足65535限制</code>，或者<code>指定multiDexEnabled = true和minimalMainDex = true</code>的情况下，才会创建的dex，其包含的class是根据classes.jar中ZipEntry的遍历顺序添加的。</p>
</li>
</ul>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/" target="_blank" rel="external">http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p><a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/">MultiDex中出现的main dex capacity exceeded解决之道</a>中我们知道main dex的class可以由maindexlist.txt指定，<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/">Android MultiDex机制杂谈</a>中我们分析了google MultiDex机制中Secondary dex的install过程，那么，我们的app在android gradle build过程中，.dex文件是怎么创建的呢？ 再者，Secondary dex中的class是按什么顺序分配到不同dex中的呢？</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="android compile tasks" scheme="http://www.ct2wj.com/tags/android-compile-tasks/"/>
    
      <category term="build system" scheme="http://www.ct2wj.com/tags/build-system/"/>
    
      <category term="dex" scheme="http://www.ct2wj.com/tags/dex/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android MultiDex机制杂谈]]></title>
    <link href="http://www.ct2wj.com/2015/12/24/android-multidex-source-code-analysis/"/>
    <id>http://www.ct2wj.com/2015/12/24/android-multidex-source-code-analysis/</id>
    <published>2015-12-24T03:53:13.000Z</published>
    <updated>2016-01-16T13:29:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex"><a href="#0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex" class="headerlink" title="0x00 为什么需要MultiDex"></a>0x00 为什么需要MultiDex</h1><p>如果你是一名android开发者，随着app功能复杂度的增加，代码量的增多和库的不断引入，你迟早会在5.0以下的某款设备上遇到：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Conversion <span class="keyword">to</span> Dalvik format failed:</span><br><span class="line">Unable <span class="keyword">to</span> execute dex: <span class="function"><span class="keyword">method</span> <span class="title">ID</span> <span class="title">not</span> <span class="title">in</span> [0, 0<span class="title">xffff</span>]:</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">trouble writing outpu<span class="variable">t:</span></span><br><span class="line">Too many field reference<span class="variable">s:</span> <span class="number">131000</span>; <span class="built_in">max</span> <span class="keyword">is</span> <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这说明你的app的main dex方法数已经超过<code>65535</code>，如果打算继续兼容5.0以下手机，你可以采用google提供的<a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html" target="_blank" rel="external">MultiDex方案</a>，但main dex方法数为什么不能超过65535呢？<br><a id="more"></a></p>
<p>其实在Dalvik的<a href="http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">invoke-kind指令集</a>中，method reference index只留了16bits，最多能调用65535个方法。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">invoke-kind <span class="comment">&#123;vC, vD, vE, vF, vG&#125;</span>, meth@BBBB</span><br><span class="line"></span><br><span class="line">B: <span class="function"><span class="keyword">method</span> <span class="title">reference</span> <span class="title">index</span> <span class="params">(16 bits)</span></span></span><br></pre></td></tr></table></figure>
<p>所以在生成dex文件的过程中，当方法数超过65535就会报错。我们可以在dx工具源码中找到一些线索：</p>
<p>dalvik/dx/src/com/android/dx/merge/IndexMap.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maps the index offsets from one dex file to those in another. For example, if</span><br><span class="line"> * you have string #5 in the old dex file, its position in the new dex file is</span><br><span class="line"> * &#123;<span class="doctag">@code</span> strings[5]&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dex target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[] stringIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] typeIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] protoIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] fieldIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] methodIds;</span><br></pre></td></tr></table></figure>
<p>可以看到，methodIds，typeIds，protoIds，fieldIds都是short[]类型，对于每个具体的method来说都是限制在16bits。google dalvik开发者在这上面挖了个坑，MultiDex就是来填坑的。</p>
<hr>
<h1 id="0x01__u4F7F_u7528MultiDex"><a href="#0x01__u4F7F_u7528MultiDex" class="headerlink" title="0x01 使用MultiDex"></a>0x01 使用MultiDex</h1><p>MultiDex出现在google官方提供的support包里面，使用的时候需要在build.gradle中加上依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">'com.android.support:multidex:1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>同时让app的Application继承MultiDexApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDexApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiDexApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也别忘了在build.gradle中修改：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">multiDexEnabled <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x02_MultiDex-install_u8FC7_u7A0B"><a href="#0x02_MultiDex-install_u8FC7_u7A0B" class="headerlink" title="0x02 MultiDex.install过程"></a>0x02 MultiDex.install过程</h1><p>先从MultiDex.install开始分析，传入的context是MultiDexApplication，loader是dalvik.system.PathClassLoader，运行时会先去app的dexDir /data/data/pkgname/code_cache/secondary-dexes下找secondary dex(除了main dex，其他都叫secondary dex，一个apk中可能存在多个secondary dex)，找到后先校验zip格式，没问题就直接installSecondaryDexes，否则会去强制从apk中重新extract secondary dex。</p>
<p>MultiDex.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">     ClassLoader loader;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         loader = context.getClassLoader();</span><br><span class="line">         ...</span><br><span class="line">         File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">         List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                <span class="comment">// Try again, but this time force a reload of the zip file.</span></span><br><span class="line">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Second time didn't work, give up</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>MultiDexExtractor.load方法中，sourceApk指向的是/data/app/pkgname.apk，然后通过getZipCrc获取apk的CRC校验码，去和最后一次CRC校验码对比，若一致或者不是forceReload，那么直接loadExistingExtractions，loadExistingExtractions直接为/data/data/pkgname/code_cache/secondary-dexes/下已经存在的.dex创建File对象；如果不一致说明apk已经被修改了，dex需要重新从apk中抽取，此时执行performExtractions。</p>
<p>MultiDexExtractor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span><br><span class="line">        <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"MultiDexExtractor.load("</span> + applicationInfo.sourceDir + <span class="string">", "</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">final</span> File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files;</span><br><span class="line">    <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to reload existing extracted secondary dex files,"</span></span><br><span class="line">                    + <span class="string">" falling back to fresh extraction"</span>, ioe);</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, <span class="string">"load found "</span> + files.size() + <span class="string">" secondary dex files"</span>);</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performExtractions中真正抽取在extract方法中，输入参数分别是：</p>
<ul>
<li>apk(ZipFile)    指向/data/app/pkgname.apk</li>
<li>dexFile(ZipEntry)    指向classes2.dex</li>
<li>extractTo(File)    指向/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes2.zip</li>
<li>extractedFilePrefix(String)    pkgname.apk.classes</li>
</ul>
<p>extract把dexFile写入到extractTo指向的一个entry，其中InputStream读的是apk中的classes2.apk，ZipOutputStream指向的是一个tmpFile，具体步骤为：</p>
<ol>
<li>在/data/data/pkgname/code_cache/secondary-dexes/创建pkgname.apk.classes12345.zip的tmpFile；</li>
<li>对步骤1的tmpFile建立ZipOutputStream；</li>
<li>创建一个指向classes.dex的ZipEntry对象；</li>
<li>向tmpFile写入这个entry；</li>
<li>将tmpFile重命名为pkgname.apk.classes2.zip，tmpFile此时还存在；</li>
<li>删除tmpFile；</li>
</ol>
<p>extract的实际效果就是在/data/data/pkgname/code_cache/secondary-dexes下创建了：</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes2.zip</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes3.zip</p>
<p>…</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classesN.zip</p>
<p>N是MultiDex拆分后dex的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(ZipFile apk, ZipEntry dexFile, File extractTo,</span><br><span class="line">        String extractedFilePrefix)</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InputStream in = apk.getInputStream(dexFile);</span><br><span class="line">    ZipOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    File tmp = File.createTempFile(extractedFilePrefix, EXTRACTED_SUFFIX,</span><br><span class="line">            extractTo.getParentFile());</span><br><span class="line">    Log.i(TAG, <span class="string">"Extracting "</span> + tmp.getPath());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmp)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZipEntry classesDex = <span class="keyword">new</span> ZipEntry(<span class="string">"classes.dex"</span>);</span><br><span class="line">            <span class="comment">// keep zip entry time since it is the criteria used by Dalvik</span></span><br><span class="line">            classesDex.setTime(dexFile.getTime());</span><br><span class="line">            out.putNextEntry(classesDex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> length = in.read(buffer);</span><br><span class="line">            <span class="keyword">while</span> (length != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">                length = in.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            out.closeEntry();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"Renaming to "</span> + extractTo.getPath());</span><br><span class="line">        <span class="keyword">if</span> (!tmp.renameTo(extractTo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to rename \""</span> + tmp.getAbsolutePath() +</span><br><span class="line">                    <span class="string">"\" to \""</span> + extractTo.getAbsolutePath() + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeQuietly(in);</span><br><span class="line">        tmp.delete(); <span class="comment">// return status ignored</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到真正的install阶段，在MultiDex中有三个私有嵌套类V19,V14和V4来负责具体的系统版本，分别对应android 4.4以上，4.0以上和4.0以下系统。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span><br><span class="line">        InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以4.4为例，V19.install其实就是对输入additionalClassPathEntries反射调用makeDexElements创建Element[]对象，再去修改dalvik.system.BaseDexClassLoader的pathList字段表示的DexPathList类中的dexElements字段内容，把Element[]对象添加进去，这样以后dalvik.system.PathClassLoader就可以找到在secondary dex中的class了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">            File optimizedDirectory)</span></span><br><span class="line">                    <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">                    NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">/* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span></span><br><span class="line">        Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Field suppressedExceptionsField =</span><br><span class="line">                    findField(loader, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                    (IOException[]) suppressedExceptionsField.get(loader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions =</span><br><span class="line">                        suppressedExceptions.toArray(</span><br><span class="line">                                <span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                IOException[] combined =</span><br><span class="line">                        <span class="keyword">new</span> IOException[suppressedExceptions.size() +</span><br><span class="line">                                        dexElementsSuppressedExceptions.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined,</span><br><span class="line">                        suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                dexElementsSuppressedExceptions = combined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的是，DexPathList:makeDexElements最终会去做dex2opt，其中optimizedDirectory就是之前的dexDir，优化后的dex文件是pkgname.apk.classes2.dex，然而dex2opt会消耗较多的cpu时间，如果全部放在main线程去处理的话，比较影响用户体验，甚至可能引起ANR。</p>
<p>DexPathList.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x03__u63A2_u660E_u7684_u5751"><a href="#0x03__u63A2_u660E_u7684_u5751" class="headerlink" title="0x03 探明的坑"></a>0x03 探明的坑</h1><ul>
<li><p>坑1 如果secondary dex文件太大，可能导致应用在安装过程中出现ANR，这个在0x02 MultiDex.install的最后也提到过，规避方法以后将继续介绍。</p>
</li>
<li><p>坑2 Dalvik linearAlloc bug (<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">Issue 22586</a>)：采用MutilDex方案的app在Android4.0以前的设备上可能会启动失败。</p>
</li>
<li><p>坑N-1 Dalvik linearAlloc limit (<a href="http://b.android.com/78035" target="_blank" rel="external">Issue 78035</a>)：使用MultiDex的app需要申请一个大内存，运行时可能导致程序crash，这个Issue在Android4.0已经修复了, 不过还是有可能在低于Android5.0的设备上出现。</p>
</li>
<li><p>坑N <a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">main dex capacity exceeded</a>，一边愉快地编译apk，一边写着代码，突然出现“main dex capacity exceeded”，build failed了… 这个时候怎么办，一种看似有效的办法是指定dex中的method数，例如：</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android.applicationVariants.all &#123;</span><br><span class="line">    variant -&gt;</span><br><span class="line">        dex.doFirst&#123;</span><br><span class="line">            dex-&gt;</span><br><span class="line">            <span class="keyword">if</span> (dex.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">                dex.additionalParameters = []</span><br><span class="line">            &#125;</span><br><span class="line">                dex.additionalParameters += <span class="string">'--set-max-idx-number=55000'</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然并卵，虽然编译没问题了，但是运行时会大概率出现<code>ClassNotFoundException</code>和<code>NoClassDefFoundError</code>导致crash，原因很简单，MultiDex.install之前依赖的所有类必须在main dex中，暴力指定main dex数量，可能导致这些类被划分到了secondary dex，系统的PathClassLoader并不能在main dex中找到全部需要加载的类！好在5.0之后，安装app时ART会对apk中所有的classes(..N).dex预编译输出为一个.oat文件，因此找不到类的情况会彻底解决，但是编译时dex过程中main dex capacity exceeded的问题却仍然存在。</p>
<p>一个解决办法是build时指定maindexlist.txt，具体可以参考本博客的另一篇文章<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>。</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/" target="_blank" rel="external">http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex"><a href="#0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex" class="headerlink" title="0x00 为什么需要MultiDex"></a>0x00 为什么需要MultiDex</h1><p>如果你是一名android开发者，随着app功能复杂度的增加，代码量的增多和库的不断引入，你迟早会在5.0以下的某款设备上遇到：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Conversion <span class="keyword">to</span> Dalvik format failed:</span><br><span class="line">Unable <span class="keyword">to</span> execute dex: <span class="function"><span class="keyword">method</span> <span class="title">ID</span> <span class="title">not</span> <span class="title">in</span> [0, 0<span class="title">xffff</span>]:</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">trouble writing outpu<span class="variable">t:</span></span><br><span class="line">Too many field reference<span class="variable">s:</span> <span class="number">131000</span>; <span class="built_in">max</span> <span class="keyword">is</span> <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这说明你的app的main dex方法数已经超过<code>65535</code>，如果打算继续兼容5.0以下手机，你可以采用google提供的<a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html">MultiDex方案</a>，但main dex方法数为什么不能超过65535呢？<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[This is the beginning of the story]]></title>
    <link href="http://www.ct2wj.com/2015/12/22/This-is-the-beginning-of-the-story/"/>
    <id>http://www.ct2wj.com/2015/12/22/This-is-the-beginning-of-the-story/</id>
    <published>2015-12-22T09:53:44.000Z</published>
    <updated>2015-12-22T10:53:20.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/Moving-Castle.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/Moving-Castle.jpg" alt=""></p>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MultiDex中出现的main dex capacity exceeded解决之道]]></title>
    <link href="http://www.ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/"/>
    <id>http://www.ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/</id>
    <published>2015-12-22T03:33:07.000Z</published>
    <updated>2016-02-15T03:14:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>随着业务的日益壮大，在集成构建实践中发现，dalvik上的MultiDex拆包频繁出现main dex capacity exceeded问题导致编译失败，对app的年末上线构成了严峻挑战。本文通过控制maindexlist中class的数量，达到减少MainDex体积，避免exceeded的目的。</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="0x01__u4E3A_u4EC0_u4E48_u4F1Amain_dex_capacity_exceeded"><a href="#0x01__u4E3A_u4EC0_u4E48_u4F1Amain_dex_capacity_exceeded" class="headerlink" title="0x01 为什么会main dex capacity exceeded"></a>0x01 为什么会main dex capacity exceeded</h1><p>在入口类<code>com.android.dx.command.dexer.Main</code>中，<br><code>processOne</code>会去调用<code>processClass</code>，一旦发现main dex的方法数超65535，会通过<code>createDexFile</code>创建一个新的Byte[]对象放入dexOutputArrays。<code>processAllFiles</code>遇到<code>dexOutputArrays.size</code> &gt; 0就会抛<code>DexException</code>，告诉我们”Too many classes in maindexlixt, main dex capacity exceeded”。</p>
<p>dalvik/dx/src/com/android/dx/command/dexer/Main.java</p>
<p><code>processAllFiles</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (args.mainDexListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// with --main-dex-list</span></span><br><span class="line">	...</span><br><span class="line"><span class="comment">// forced in main dex</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">                processOne(fileNames[i], mainPassFilter);</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="keyword">if</span> (dexOutputArrays.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">"Too many classes in "</span> + Arguments.MAIN_DEX_LIST_OPTION</span><br><span class="line">                        + <span class="string">", main dex capacity exceeded"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">	...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>processClass</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processClass</span><span class="params">(String name, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">int</span> numMethodIds = outputDex.getMethodIds().items().size();</span><br><span class="line">      <span class="keyword">int</span> numFieldIds = outputDex.getFieldIds().items().size();</span><br><span class="line">      <span class="keyword">int</span> constantPoolSize = cf.getConstantPool().size();</span><br><span class="line">      <span class="keyword">int</span> maxMethodIdsInDex = numMethodIds + constantPoolSize + cf.getMethods().size() +</span><br><span class="line">              MAX_METHOD_ADDED_DURING_DEX_CREATION;</span><br><span class="line">      <span class="keyword">int</span> maxFieldIdsInDex = numFieldIds + constantPoolSize + cf.getFields().size() +</span><br><span class="line">              MAX_FIELD_ADDED_DURING_DEX_CREATION;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (args.multiDex</span><br><span class="line">          &amp;&amp; (outputDex.getClassDefs().items().size() &gt; <span class="number">0</span>)</span><br><span class="line">          &amp;&amp; ((maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex) ||</span><br><span class="line">              (maxFieldIdsInDex &gt; args.maxNumberOfIdxPerDex))) &#123;</span><br><span class="line">          DexFile completeDex = outputDex;</span><br><span class="line">          createDexFile();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x02__u600E_u4E48_u907F_u514D"><a href="#0x02__u600E_u4E48_u907F_u514D" class="headerlink" title="0x02 怎么避免"></a>0x02 怎么避免</h1><p>怎么才能避免maindex方法数超65535呢？ 关键在控制好<strong>maindexlist.txt中类的数量</strong>。</p>
<hr>
<h1 id="0x03_maindexlist-txt_u7684_u751F_u6210"><a href="#0x03_maindexlist-txt_u7684_u751F_u6210" class="headerlink" title="0x03 maindexlist.txt的生成"></a>0x03 maindexlist.txt的生成</h1><p>android gradle plugin中，有一个类专门负责创建maindexlist.txt，叫做<code>CreateMainDexList</code>，源码位于：</p>
<p>tools/base/build-system/gradle-core/src/main/groovy/com/android/build/gradle/internal/tasks/multidex/CreateMainDexList.groovy</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@TaskAction</span></span><br><span class="line"><span class="typename">void</span> output() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getAllClassesJarFile() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"No input file"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manifest components plus immediate dependencies must be in the main dex.</span></span><br><span class="line">    File _allClassesJarFile = getAllClassesJarFile()</span><br><span class="line">    Set&lt;String&gt; mainDexClasses = callDx(_allClassesJarFile, getComponentsJarFile())</span><br></pre></td></tr></table></figure>
<p><code>callDx</code>最终调用<code>AndroidBuilder.createMainDexList</code>，实际是通过开启后台进程执行<code>ClassReferenceListBuilder.main</code>(5.0之前叫<code>MainDexListBuilder</code>)去分析类的依赖关系，生成一个maindexlist.txt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    ZipFile jarOfRoots;</span><br><span class="line">    jarOfRoots = <span class="keyword">new</span> ZipFile(args[<span class="number">0</span>]);</span><br><span class="line">...</span><br><span class="line">    Path path = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        path = <span class="keyword">new</span> Path(args[<span class="number">1</span>]);</span><br><span class="line">        ClassReferenceListBuilder builder = <span class="keyword">new</span> ClassReferenceListBuilder(path);</span><br><span class="line">        builder.addRoots(jarOfRoots);</span><br><span class="line">        printList(builder.toKeep);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>为了确定<code>ClassReferenceListBuilder.main</code>输入参数，用<a href="http://jboss-javassist.github.io/javassist/" target="_blank" rel="external">javassist.jar</a>来运行时改写ClassReferenceListBuilder.class文件。在main方法第一行加上<code>System.err.println（java.util.Arrays.toString(args))</code>，目的是把标准错误输出流打印到终端。另外保险起见，通过PrintWriter同时把参数输出到本地文件log.txt。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/printArgs.jpg" alt=""></p>
<p>修改后发现，gradle build进程的标准错误输出流没打印出来，很可能被重定向了，不过本地log.txt记录下了参数信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[[省略...]/release/componentClasses.jar, [省略...]/release/classes.jar]</span><br></pre></td></tr></table></figure>
<p>可见arg[0]是componentClasses.jar， arg[1]是app完整的classes.jar。</p>
<p><code>ClassReferenceListBuilder.addRoots</code>通过读文件遍历componentClasses.jar的每个entry，再调用<code>addDependencies</code>分析这个类的依赖关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoots</span><span class="params">(ZipFile jarOfRoots)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">...	</span><br><span class="line">      <span class="keyword">for</span> (Enumeration&lt;? extends ZipEntry&gt; entries = jarOfRoots.entries();</span><br><span class="line">              entries.hasMoreElements();) &#123;</span><br><span class="line">          ZipEntry entry = entries.nextElement();</span><br><span class="line">          String name = entry.getName();</span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(CLASS_EXTENSION)) &#123;</span><br><span class="line">              DirectClassFile classFile;</span><br><span class="line">			...</span><br><span class="line">                  classFile = path.getClass(name);</span><br><span class="line">			...</span><br><span class="line">              addDependencies(classFile.getConstantPool());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>addDependencies</code>从ConstantPool得到import类，调用<code>addClassWithHierachy</code>继续分析继承关系（其实也可以通过javap -verbose先反汇编，再分析匹配”= class”的字符串来获取，具体可以参考本文的<a href="https://github.com/JLLK/ClassDependenceAnalyser" target="_blank" rel="external">依赖分析工具</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDependencies</span><span class="params">(ConstantPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Constant constant : pool.getEntries()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> CstType) &#123;</span><br><span class="line">            Type type = ((CstType) constant).getClassType();</span><br><span class="line">            String descriptor = type.getDescriptor();</span><br><span class="line">            <span class="keyword">if</span> (descriptor.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastBrace = descriptor.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">                <span class="keyword">if</span> (lastBrace &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    addClassWithHierachy(descriptor.substring(<span class="number">1</span>, descriptor.length()-<span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">assert</span> descriptor.length() &gt; lastBrace + <span class="number">3</span></span><br><span class="line">                    &amp;&amp; descriptor.charAt(lastBrace + <span class="number">1</span>) == <span class="string">'L'</span>;</span><br><span class="line">                    addClassWithHierachy(descriptor.substring(lastBrace + <span class="number">2</span>,</span><br><span class="line">                            descriptor.length() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖关系分析结束后，输出maindexlist.txt，这里标准输出已经重定向到了maindexlist.txt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Set&lt;String&gt; toKeep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String classDescriptor : toKeep) &#123;</span><br><span class="line">        System.out.print(classDescriptor);</span><br><span class="line">        System.out.println(CLASS_EXTENSION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x04_componentClasses-jar_u7684_u6765_u6E90"><a href="#0x04_componentClasses-jar_u7684_u6765_u6E90" class="headerlink" title="0x04 componentClasses.jar的来源"></a>0x04 componentClasses.jar的来源</h1><p>经过前面的分析，其实可以看出componentClasses.jar最终决定了maindexlist.txt的大小。</p>
<p>而componentClasses.jar是proguardComponentsTask根据manifest_keep.txt从allclasses.jar中抽取生成的，manifest_keep.txt内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">app</span>.<span class="title">XXXXApplication</span> </span>&#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(android.content.Context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">splash</span>.<span class="title">XXXXActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">app</span>.<span class="title">MainActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">login</span>.<span class="title">xxxx</span>.<span class="title">LoginActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">sidebar</span>.<span class="title">account</span>.<span class="title">XXAccountActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么manifest_keep.txt由谁生成的呢？ </p>
<p>其实是<code>CreateManifestKeepList</code>解析AndroidManifest.xml文件得到的，可以找到：</p>
<p>./tools/base/build-system/gradle-core/src/main/groovy/com/android/build/gradle/internal/tasks/multidex/CreateManifestKeepList.groovy</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">*</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">backup</span>.<span class="title">BackupAgent</span> &#123;</span></span><br><span class="line">    &lt;init&gt;();</span><br><span class="line">&#125;</span><br><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">*</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> &#123;</span></span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">   <span class="annotation">@TaskAction</span></span><br><span class="line">   <span class="typename">void</span> generateKeepListFromManifest() &#123;</span><br><span class="line">       SAXParser parser = SAXParserFactory.newInstance().newSAXParser()</span><br><span class="line"></span><br><span class="line">       Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(getOutputFile()))</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           parser.parse(getManifest(), <span class="keyword">new</span> ManifestHandler(out))</span><br><span class="line">           out.write(</span><br><span class="line"><span class="string">"""-keep public class * extends android.app.backup.BackupAgent &#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">&#125;</span><br><span class="line">-keep public class * extends java.lang.annotation.Annotation &#123;</span><br><span class="line">   *;</span><br><span class="line">&#125;</span><br><span class="line">"""</span>)</span><br></pre></td></tr></table></figure>
<p>上面<code>getOutputFile</code>返回的就是manifest_keep.txt，<code>CreateManifestKeepList</code>私有内部类<code>ManifestHandler</code>用<code>CreateManifestKeepList.KEEP_SPECS[qName]</code>决定哪些类需要放入manifest_keep.txt。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ManifestHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attr)</span> </span>&#123;</span><br><span class="line">        String keepSpec = CreateManifestKeepList.KEEP_SPECS[qName]</span><br><span class="line">        <span class="keyword">if</span> (keepSpec) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> keepIt = <span class="function"><span class="keyword">true</span></span><br><span class="line">            <span class="title">if</span> <span class="params">(CreateManifestKeepList.<span class="keyword">this</span>.filter)</span> </span>&#123;</span><br><span class="line">                Map&lt;String, String&gt; attrMap = [:]</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attr.getLength(); i++) &#123;</span><br><span class="line">                    attrMap[attr.getQName(i)] = attr.getValue(i)</span><br><span class="line">                &#125;</span><br><span class="line">                keepIt = CreateManifestKeepList.<span class="keyword">this</span>.filter(qName, attrMap)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (keepIt) &#123;</span><br><span class="line">                String nameValue = attr.getValue(<span class="string">'android:name'</span>)</span><br><span class="line">                <span class="keyword">if</span> (nameValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.write((String) <span class="string">"-keep class $&#123;nameValue&#125; $keepSpec\n"</span>)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>用来过滤的<code>KEEP_SPECS</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="type">String</span> <span class="type">DEFAULT_KEEP_SPEC</span> = <span class="string">"&#123; &lt;init&gt;(); &#125;"</span></span><br><span class="line">   <span class="keyword">private</span> static <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; <span class="type">KEEP_SPECS</span> = [</span><br><span class="line">       <span class="symbol">'applicatio</span>n'       : <span class="string">"""&#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">   void attachBaseContext(android.content.Context);</span><br><span class="line">&#125;"""</span>,</span><br><span class="line">       <span class="symbol">'activit</span>y'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'servic</span>e'           : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'receive</span>r'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'provide</span>r'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'instrumentatio</span>n'   : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
<p>可见，至少AndroidManifest.xml中<code>application</code>,<code>activity</code>,<code>service</code>,<code>receiver</code>,<code>provider</code>,<code>instrumentation</code>这6种标签的类，以及继承至<code>java.lang.annotation.Annotation</code>和<code>android.app.backup.BackupAgent</code>的类会用来产生maindexlist.txt。</p>
<hr>
<h1 id="0x05__u89E3_u51B3_u4E4B_u9053"><a href="#0x05__u89E3_u51B3_u4E4B_u9053" class="headerlink" title="0x05 解决之道"></a>0x05 解决之道</h1><p>本文绕过gradle build工具make componentClasses.jar的方式，不纠结于如何控制componentClasses.jar，而是直接指定哪些类需要放进maindexlist.txt，从而减少maindexlist类数量，避免main dex capacity exceeded的出现。具体方法如下：</p>
<p>首先从app的com.xxxx.sdk.app.XXXXApplication类出发，分析出MultiDex.install之前的所有必须放入maindex的类（MultiDex包也需并入分析），输出到maindexlist.txt。<strong>正确分析依赖关系非常重要</strong>，否则运行时一定出现<code>ClassNotFoundException</code>。XXXXApplication对外依赖则<strong>越少越好</strong>，甚至可以通过java反射和动态加载特性让其仅依赖android.jar和部分接口类。</p>
<p>另外加载过程中，被加载类的static initializer块里（clinit）用到的类和inner类也会被classloader主动加载，需要确保在maindexlist.txt中，可以使用本人scala写的<a href="https://github.com/JLLK/ClassDependenceAnalyser" target="_blank" rel="external">依赖分析工具</a>来进行分析，得到足够小的maindexlist.txt。</p>
<p>最后，还需在build.gradle中加上：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">"dex"</span>)</span><br><span class="line">    &#125;.each &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// optional</span></span><br><span class="line">    dx.additionalParameters += <span class="string">"--main-dex-list=$projectDir/maindexlist.txt"</span>.toString()</span><br><span class="line">    dx.additionalParameters += <span class="string">"--minimal-main-dex"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文中，最后的maindexlist.txt类数量成功由4000减少到1116，maindex体积由7M减少到1.3M，du -sh *.dex输出如下：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/maindex_output.png?imageView2/2/w/150" alt=""></p>
<p>从此再也不用担心main dex capacity exceeded了^_-</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>随着业务的日益壮大，在集成构建实践中发现，dalvik上的MultiDex拆包频繁出现main dex capacity exceeded问题导致编译失败，对app的年末上线构成了严峻挑战。本文通过控制maindexlist中class的数量，达到减少MainDex体积，避免exceeded的目的。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="build" scheme="http://www.ct2wj.com/tags/build/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
</feed>
