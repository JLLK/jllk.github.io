<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[tomchen&fleur.wang's moving castle]]></title>
  <subtitle><![CDATA[This dog is lazy, left nothing]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.ct2wj.com/"/>
  <updated>2016-02-09T13:32:52.000Z</updated>
  <id>http://www.ct2wj.com/</id>
  
  <author>
    <name><![CDATA[tomchen]]></name>
    <email><![CDATA[tomchenv5@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一种按模块拆分和适机加载dex的方法]]></title>
    <link href="http://www.ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/"/>
    <id>http://www.ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/</id>
    <published>2016-02-09T10:59:53.000Z</published>
    <updated>2016-02-09T13:32:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一个功能成熟的app可能由多个业务平行的模块构成，由于业务是平行的，这些模块之间也应该是独立的没有耦合。本文希望在构建app时，每个平行业务线x对应的模块的class可以分解到dex(..x)中，这样做的好处是：</p>
<ul>
<li>maindex不会引入业务代码，可减少maindex体积</li>
<li>运行时，可延迟加载业务dex，减少app启动时间</li>
<li>能做一些有趣的工作，例如统计各个业务线模块启动时间</li>
</ul>
<p>本文在google multidex的基础上，通过应用<a href="https://github.com/JLLK/multidex-maker" target="_blank" rel="external">multidex-maker</a>,<a href="https://github.com/JLLK/multidex-installer" target="_blank" rel="external">multidex-installer</a>和<a href="https://github.com/JLLK/multidex-hook" target="_blank" rel="external">multidex-hook</a>，实现secondary dex的按模块拆分和适机延迟加载，并在文章最后给出了一个示例app：<a href="https://github.com/JLLK/multidex-sample" target="_blank" rel="external">multidex-sample</a>。<br><a id="more"></a></p>
<hr>
<h1 id="0x01_multidex-maker"><a href="#0x01_multidex-maker" class="headerlink" title="0x01 multidex-maker"></a>0x01 multidex-maker</h1><p><a href="https://github.com/JLLK/multidex-maker" target="_blank" rel="external">multidex-maker</a>(<a href="https://github.com/JLLK/multidex-maker" target="_blank" rel="external">https://github.com/JLLK/multidex-maker</a>)用来确保每个模块的class划分到自己的secondary dex。安装multidex-maker首先需要执行<code>./install.sh</code>。这一步会先编译multidex-maker，输出dx.jar。</p>
<p>请检查<code>~/Library/Android/sdk/platforms/android-${SDK_VERSION}/android.jar</code>中<code>SDK_VERSION</code>是否存在（默认是<code>17</code>)，编译完成后，会自动替换<code>~/Library/Android/sdk/build-tools/${BUILD_TOOL_VERSION}/lib</code>下的dx.jar，<code>BUILD_TOOL_VERSION</code>默认是<code>23.0.1</code>，如果build-tools中没有<code>23.0.1</code>请换成其他版本：</p>
<p>install.sh</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDK_VERSION=<span class="number">17</span>			<span class="comment"># change to your version</span></span><br><span class="line"></span><br><span class="line">BUILD_TOOL_VERSION=<span class="number">23.0</span>.<span class="number">1</span>	<span class="comment"># change to your version</span></span><br></pre></td></tr></table></figure>
<p>然后，在<code>build.gradle</code>中加上：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        tasks.matching &#123;</span><br><span class="line">            it.name.startsWith(<span class="string">"dex"</span>)</span><br><span class="line">        &#125;.each &#123; dx -&gt;</span><br><span class="line">            <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">                dx.additionalParameters = []</span><br><span class="line">            &#125;</span><br><span class="line">            dx.additionalParameters += <span class="string">"--main-dex-list=$projectDir/maindexlist.txt"</span>.toString()</span><br><span class="line">            dx.additionalParameters += <span class="string">"--secondary-dexes-list=$projectDir/secondarydexeslist.txt"</span>.toString()</span><br><span class="line">            dx.additionalParameters += <span class="string">"--minimal-main-dex"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>--secondary-dexes-list</code>是multidex-maker新加的编译参数，可以带上一个secondarydexeslist.txt文件，支持用<code>--secondary-dex-begin</code>和<code>--secondary-dex-end</code>把需要单独拆成dex的module的包名包含进来，例如示例app中的secondarydexeslist.txt：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span>    </span><br><span class="line"></span>com/github/jllk/multidex/sample/R</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span>    </span><br><span class="line"></span>scala/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span>	</span><br><span class="line"></span>com/github/jllk/multidex/sample/a/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span></span><br><span class="line"></span>com/github/jllk/multidex/sample/b/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span></span><br><span class="line"></span>com/github/jllk/multidex/sample/c/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">begin</span></span><br><span class="line"></span>com/github/jllk/multidex/sample/d/</span><br><span class="line">-<span class="ruby">-secondary-dex-<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>安装完成multidex-maker之后，在gradle build app时可以得到一个<strong>按模块拆分成多个secondary dex</strong>的app。</p>
<hr>
<h1 id="0x02_multidex-installer"><a href="#0x02_multidex-installer" class="headerlink" title="0x02 multidex-installer"></a>0x02 multidex-installer</h1><p>如果仅仅拆分了secondary dex，app应该还<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">不能运行</a>。一种解决方法是我们可以采用google multidex库的支持，选择在<code>Application.attachBaseContext</code>时调用<code>MultiDex.install(this)</code>。但这样会将secondary dexes一次性加载进来，失去了根据业务线的实际情况加载dex的优势。</p>
<p><a href="https://github.com/JLLK/multidex-installer" target="_blank" rel="external">multidex-installer</a>(<a href="https://github.com/JLLK/multidex-installer" target="_blank" rel="external">https://github.com/JLLK/multidex-installer</a>)支持按dex索引来加载dex，提供了三种加载方案：<code>installAll</code>、<code>installOne</code>和<code>installRange</code>：</p>
<p>JLLKMultiDexInstaller.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Install all dexes in sourceApk</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installAll</span><span class="params">(Context context)</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Install one dex by index</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installOne</span><span class="params">(Context context, <span class="keyword">int</span> dexIndex)</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Install dexes by range index</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installRange</span><span class="params">(Context context, <span class="keyword">int</span> startDexIndex, <span class="keyword">int</span> endDexIndex)</span></span></span><br></pre></td></tr></table></figure>
<p>使用multidex-installer需要在build.gradle中添加：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    compile <span class="string">"com.github.jllk:multidex-installer:0.0.4-beta@aar"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>attachBaseContext</code>，添加几行代码，让multidex-installer工作起来：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleApp</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">attachBaseContext</span>(</span>base: <span class="type">Context</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base)</span><br><span class="line">    <span class="type">JLLKMultiDexInstaller</span>.installOne(<span class="keyword">this</span>, <span class="number">2</span>) <span class="comment">// for R</span></span><br><span class="line">    <span class="type">JLLKMultiDexInstaller</span>.installRange(<span class="keyword">this</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// for scala</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x03_multidex-hook"><a href="#0x03_multidex-hook" class="headerlink" title="0x03 multidex-hook"></a>0x03 multidex-hook</h1><p>app启动时，在<code>Application.attachBaseContext</code>中加载dex也许不是最好的时机，假如用户没有使用模块A的功能，模块A对应的dex是没必要立刻加载的。更好的办法是在恰当的时机延迟加载dex，本文称为<strong>适机加载</strong>。</p>
<p>为此，本文提出了<a href="https://github.com/JLLK/multidex-hook" target="_blank" rel="external">multidex-hook</a>(<a href="https://github.com/JLLK/multidex-hook" target="_blank" rel="external">https://github.com/JLLK/multidex-hook</a>)，通过hook本应用进程的<code>Instrumentation</code>，在<code>Instrumentation.execStartActivity</code>方法被调用时，根据所启动模块的Activity的完全限定名来获得dex索引，再用multidex-installer加载相应dex。</p>
<p>JLLKInstrumentationProxy.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ActivityResult <span class="title">execStartActivityProxy</span><span class="params">(Context who, Intent intent, IExecStartActivityDelegate delegate)</span> </span>&#123;</span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent().getClassName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ResolveInfo resolveInfo = getContext().getPackageManager()</span><br><span class="line">                .resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">        <span class="keyword">if</span> (resolveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            className = resolveInfo.activityInfo.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        className = intent.getComponent().getClassName();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.d(TAG, <span class="string">"[execStartActivityProxy] "</span> + className);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install secondary dex by index.</span></span><br><span class="line">    <span class="keyword">int</span> dexIdx = JLLKMultiDexHook.getModuleDexIdx(className);</span><br><span class="line">    <span class="keyword">if</span> (dexIdx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        JLLKMultiDexInstaller.installOne(who, dexIdx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.execStartActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x04_multidex-sample"><a href="#0x04_multidex-sample" class="headerlink" title="0x04 multidex-sample"></a>0x04 multidex-sample</h1><p>本文的最后介绍示例app <a href="https://github.com/JLLK/multidex-sample" target="_blank" rel="external">multidex-sample</a>(<a href="https://github.com/JLLK/multidex-sample" target="_blank" rel="external">https://github.com/JLLK/multidex-sample</a>)，它同时用到了multidex-maker，multidex-installer和multidex-hook。构建完成后，multidex-sample输出的dex如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; du -sh *<span class="class">.dex</span></span><br><span class="line"><span class="number">40</span>K	classes<span class="class">.dex</span></span><br><span class="line"><span class="number">4.0</span>K	classes2<span class="class">.dex</span></span><br><span class="line"><span class="number">7.0</span>M	classes3<span class="class">.dex</span></span><br><span class="line"><span class="number">1.7</span>M	classes4<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes5<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes6<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes7<span class="class">.dex</span></span><br><span class="line"><span class="number">12</span>K	classes8<span class="class">.dex</span></span><br><span class="line"><span class="number">28</span>K	classes9.dex</span><br></pre></td></tr></table></figure>
<p>其中，maindex（图左）仅包含multidex-installer和multidex-hook以及各模块X（a,b,c）的入口SampleActivityX，模块A（图右）仅包含业务相关的class：</p>
<table>
<thead>
<tr>
<th style="text-align:center">maindex</th>
<th style="text-align:center">Secondary dex: module A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/maindex.png?imageView2/2/w/300" alt=""></td>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/module-A.png?imageView2/2/w/320" alt=""></td>
</tr>
</tbody>
</table>
<p>以及完美的运行：</p>
<table>
<thead>
<tr>
<th style="text-align:center">MainActivity</th>
<th style="text-align:center">SampleActivityA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/MainActivity.png?imageView2/2/w/280" alt=""></td>
<td style="text-align:center"><img src="http://7xpcru.com1.z0.glb.clouddn.com/ActivityA.png?imageView2/2/w/280" alt=""></td>
</tr>
</tbody>
</table>
<p>Done! ^_-</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/" target="_blank" rel="external">http://ct2wj.com/2016/02/09/the-way-to-make-and-lazy-load-secondary-dexes-according-to-the-module/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>一个功能成熟的app可能由多个业务平行的模块构成，由于业务是平行的，这些模块之间也应该是独立的没有耦合。本文希望在构建app时，每个平行业务线x对应的模块的class可以分解到dex(..x)中，这样做的好处是：</p>
<ul>
<li>maindex不会引入业务代码，可减少maindex体积</li>
<li>运行时，可延迟加载业务dex，减少app启动时间</li>
<li>能做一些有趣的工作，例如统计各个业务线模块启动时间</li>
</ul>
<p>本文在google multidex的基础上，通过应用<a href="https://github.com/JLLK/multidex-maker">multidex-maker</a>,<a href="https://github.com/JLLK/multidex-installer">multidex-installer</a>和<a href="https://github.com/JLLK/multidex-hook">multidex-hook</a>，实现secondary dex的按模块拆分和适机延迟加载，并在文章最后给出了一个示例app：<a href="https://github.com/JLLK/multidex-sample">multidex-sample</a>。<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="SecondaryDex" scheme="http://www.ct2wj.com/tags/SecondaryDex/"/>
    
      <category term="build system" scheme="http://www.ct2wj.com/tags/build-system/"/>
    
      <category term="dex" scheme="http://www.ct2wj.com/tags/dex/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[groovy动态特性浅析：从MOP到DSL]]></title>
    <link href="http://www.ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/"/>
    <id>http://www.ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/</id>
    <published>2016-01-16T13:04:21.000Z</published>
    <updated>2016-01-17T14:04:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>groovy作为一门基于jvm的动态类型语言，与java, scala等jvm静态类型语言的主要区别在哪呢，为什么gradle选择groovy实现自己的DSL? 它的优势在哪？</p>
</blockquote>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/614px-Groovy-logo.svg.png" alt=""></p>
<a id="more"></a>
<hr>
<h1 id="0x01__u9759_u6001_u548C_u52A8_u6001"><a href="#0x01__u9759_u6001_u548C_u52A8_u6001" class="headerlink" title="0x01 静态和动态"></a>0x01 静态和动态</h1><p>java是一门类型安全的语言，这种“安全”源于编译时编译器和运行时jvm对类型的检查。拥有编译时类型检查能力的语言，称为<code>静态类型</code>语言。静态语言能让类型错误尽量在编译时暴露，而非推迟到运行时，缺点是不利于快速编码和试错。与C++相比，java编译器做了许多工作，比如java泛型也是由编译器保证的。此外，由于在运行时jvm也会判断类型，所以java还是一种<code>强类型</code>的语言。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/languagesTypes.jpg" alt=""></p>
<p>groovy和java本质上没区别，甚至可以看做是java的一个强大的语法糖，它的特点之一是<code>动态类型</code>，groovyc并不会去检查类型，编译后的代码在执行过程中大量使用了反射，这样做的好处是：</p>
<ul>
<li>没有强制类型转换，不用和编译器较劲了^_-</li>
<li>调用方法时，不用立马关心方法的实现，让代码写起来非常灵活</li>
<li>方便支持元编程，能在运行时动态添加方法和属性，便于设计DSL</li>
</ul>
<p>我们可以比较这几段代码来感受一下java和groovy反射调用时的区别：</p>
<p>FleurWang.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FleurWang</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"hello wonderland!"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HolyHoleInJava.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HolyHoleInJava</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jumpInto</span><span class="params">(Object somebody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = somebody.getClass().getMethod(<span class="string">"say"</span>);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object msg = method.invoke(somebody);</span><br><span class="line">            System.out.println(<span class="string">"someone jump into HolyHoleInJava, and say: "</span> + msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HolyHolyInGroovy.groovy</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HolyHoleInGroovy</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="keyword">static</span> jumpIntoGroovy(somebody) &#123;</span><br><span class="line">        println <span class="string">"someone jump into HolyHoleInGroovy, and say: $&#123;somebody.say()&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">girl = <span class="keyword">new</span> FleurWang()</span><br><span class="line">HolyHoleInJava.jumpInto(girl)</span><br><span class="line">HolyHoleInGroovy.jumpIntoGroovy(girl)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someone jump <span class="keyword">into</span> HolyHoleInJava, <span class="keyword">and</span> <span class="command">say</span>: hello wonderland!</span><br><span class="line">someone jump <span class="keyword">into</span> HolyHoleInGroovy, <span class="keyword">and</span> <span class="command">say</span>: hello wonderland!</span><br></pre></td></tr></table></figure>
<p>当然groovy也有一些还不够好的地方，例如：</p>
<ul>
<li>失去了编译时的类型检查，作为弥补，需要引入大量的单元测试代码来保证代码质量。</li>
<li>相比java和scala混编，从java调用groovy代码很不方便。可以看下面代码感受一下~_~</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroovyShell shell = <span class="keyword">new</span> GroovyShell();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            shell.evaluate(<span class="keyword">new</span> File(<span class="string">"HolyHoleInGroovy.groovy"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过从groovy调java代码还是挺方便的，以及java各种优秀的开源库支持，再加上groovy自身的优点，这也许就是groovy成为gradle的DSL的原因。</p>
<hr>
<h1 id="0x02__u5143_u7F16_u7A0B_u548C_u5143_u5BF9_u8C61_u534F_u8BAE"><a href="#0x02__u5143_u7F16_u7A0B_u548C_u5143_u5BF9_u8C61_u534F_u8BAE" class="headerlink" title="0x02 元编程和元对象协议"></a>0x02 元编程和元对象协议</h1><p>我们知道java中的类加载后行为就确定了，而groovy中的类却是动态可变的，这是因为groovy支持元编程（虽然也能用其他手段改变，如native hook，运行时修改字节码等，但这里只讨论语言特性是否支持)。元编程(metaprogramming)是指代码在运行时可以动态改变自己的行为，元对象协议(MOP, Meta-Object Protocol)用来保证动态语言中元编程能力。在groovy中，元对象协议主要通过反射、元类(metaclass)、expandos等技术实现。</p>
<p>groovy世界中的类继承至java.lang.Object，并且实现了groovy.lang.GroovyObject接口，这个接口定义的invokeMethod, xxxProperty, xxxMetaClass让groovy对象具有动态扩展方法和属性的能力。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> groovy.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroovyObject</span> &#123;</span>	Object invokeMethod(String name, Object args); </span><br><span class="line">	Object getProperty(String property);	<span class="typename">void</span> setProperty(String property, Object newValue); </span><br><span class="line">	MetaClass getMetaClass();	<span class="typename">void</span> setMetaClass(MetaClass metaClass);￼￼￼￼￼￼￼￼&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们可以通过setMetaClass来改变FleurWang的行为。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">girl = <span class="keyword">new</span> FleurWang()</span><br><span class="line"></span><br><span class="line">girl.metaClass.laughAt = &#123; somebody -&gt;</span><br><span class="line">    System.out.println(<span class="string">"$&#123;delegate.class.getSimpleName()&#125; is laughing at $somebody"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">girl.laughAt(<span class="string">"tomchen"</span>)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FleurWang <span class="keyword">is</span> laughing <span class="keyword">at</span> tomchen</span><br></pre></td></tr></table></figure>
<p>无论是java对象，还是groovy对象，每个对象的都有自己对应的MetaClass。groovy运行时生成进程唯一的MetaClassRegister对象，用于管理MetaClass和Class以及对象的映射关系。对于普通java对象而言，当它的方法被调用时，groovy会先去MetaClassRegister拿它的MetaClass看是否存在同名且同签名的方法。没有的话再去执行java对象本身的方法。因此，MetaClass的方法优先级高于原生方法。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/groovy2java.jpg" alt=""></p>
<p>对于groovy对象方法调用的容错会稍微多一点，groovy运行时会先检查对象是不是实现了GroovyInterceptable接口，是的话直接调用invokeMethod，否则会去MetaClass中找，如果没找到，那么会去Groovy对象本身找，还是没有的话，会去找Groovy对象否存在和方法同名的Closure类型字段closure，找到的话就直接closure()了。如果连这个字段都没有，也不会放弃，会尝试调用Groovy对象中的methodMissing方法，万一连这个也没有-_-，groovy还是会去做最后的努力，调用GroovyObject的invokeMethod()，没实现的话就会抛MissingMethodException。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/How%20Groovy%20handles%20method%20calls%20on%20a%20POGO.png" alt=""></p>
<hr>
<h1 id="0x03__u4E00_u4E2A_u7B80_u5355_u7684DSL"><a href="#0x03__u4E00_u4E2A_u7B80_u5355_u7684DSL" class="headerlink" title="0x03 一个简单的DSL"></a>0x03 一个简单的DSL</h1><p>利用groovy的动态特性和元编程能力来构造一个简单的DSL：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingCastle</span> &#123;</span></span><br><span class="line">    <span class="keyword">def</span> level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> result = <span class="keyword">new</span> StringWriter()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> members(closure) &#123;</span><br><span class="line">        result &lt;&lt; <span class="string">"tomchen&amp;fluer.wang's moving castle:\n"</span></span><br><span class="line">        closure.delegate = <span class="keyword">this</span></span><br><span class="line">        closure()</span><br><span class="line">        println result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> methodMissing(String name, args) &#123;</span><br><span class="line">        handle(name, args)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> propertyMissing(String name) &#123;</span><br><span class="line">        Object[] emptyArray = []</span><br><span class="line">        handle(name, emptyArray)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> handle(String name, args) &#123;</span><br><span class="line">        level++</span><br><span class="line">        level.times &#123;</span><br><span class="line">            result &lt;&lt; <span class="string">" "</span></span><br><span class="line">        &#125;</span><br><span class="line">        result &lt;&lt; name.replaceAll(<span class="string">"_"</span>, <span class="string">" "</span>)</span><br><span class="line">        result &lt;&lt; printParameters(args)</span><br><span class="line">        result &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span> &amp;&amp; args[-<span class="number">1</span>] <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">            <span class="keyword">def</span> theClosure = args[-<span class="number">1</span>]</span><br><span class="line">            theClosure.delegate = <span class="keyword">this</span></span><br><span class="line">            theClosure()</span><br><span class="line">        &#125;</span><br><span class="line">        level--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> printParameters(args) &#123;</span><br><span class="line">        <span class="keyword">def</span> values = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">            values += <span class="string">" ["</span></span><br><span class="line">            <span class="keyword">def</span> count = <span class="number">0</span></span><br><span class="line">            args[<span class="number">0</span>].each &#123; key, value -&gt;</span><br><span class="line">                count++</span><br><span class="line">                values += (count &gt; <span class="number">1</span> ? " " : <span class="string">""</span>)</span><br><span class="line">                values += <span class="string">"$&#123;key&#125;: $&#123;value&#125;"</span></span><br><span class="line">            &#125;</span><br><span class="line">            values += <span class="string">"]"</span></span><br><span class="line">        &#125;</span><br><span class="line">        values</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">castle = <span class="keyword">new</span> MovingCastle()</span><br><span class="line">castle.members &#123;</span><br><span class="line">    tomchen &#123;</span><br><span class="line">        about(<span class="string">github:</span> <span class="string">"https://github.com/jllk"</span>)</span><br><span class="line">        lauguage &#123;</span><br><span class="line">            java</span><br><span class="line">            scala</span><br><span class="line">            c</span><br><span class="line">            golang</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fluerWang &#123;</span><br><span class="line">        about(<span class="string">github:</span> <span class="string">"https://github.com/fleurWang"</span>)</span><br><span class="line">        lauguage &#123;</span><br><span class="line">            javascript</span><br><span class="line">            html</span><br><span class="line">            css</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tomchen&amp;fluer.wang's moving castle:</span><br><span class="line"> tomchen</span><br><span class="line">  <span class="keyword">about</span> [github: https:<span class="comment">//github.com/jllk]</span></span><br><span class="line">  lauguage</span><br><span class="line">   java</span><br><span class="line">   <span class="keyword">scala</span></span><br><span class="line">   c</span><br><span class="line">   golang</span><br><span class="line"> fluerWang</span><br><span class="line">  <span class="keyword">about</span> [github: https:<span class="comment">//github.com/fleurWang]</span></span><br><span class="line">  lauguage</span><br><span class="line">   javascript</span><br><span class="line">   html</span><br><span class="line">   css</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h4><p>[1]. <a href="https://pragprog.com/book/vslg2/programming-groovy-2" target="_blank" rel="external">programming Groovy 2</a></p>
<p>[2]. <a href="http://www.amazon.com/Groovy-Domain-Specific-Languages-Fergal-Dearle/dp/1849695407/ref=sr_1_1?ie=UTF8&amp;qid=1452654163&amp;sr=8-1&amp;keywords=Groovy_for_Domain-Specific_Languages" target="_blank" rel="external">Groovy for Domain-Specific Languages - Second Edition</a></p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/" target="_blank" rel="external">http://ct2wj.com/2016/01/16/groovy-from-MOP-to-DSL/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>groovy作为一门基于jvm的动态类型语言，与java, scala等jvm静态类型语言的主要区别在哪呢，为什么gradle选择groovy实现自己的DSL? 它的优势在哪？</p>
</blockquote>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/614px-Groovy-logo.svg.png" alt=""></p>]]>
    
    </summary>
    
      <category term="DSL" scheme="http://www.ct2wj.com/tags/DSL/"/>
    
      <category term="MOP" scheme="http://www.ct2wj.com/tags/MOP/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="groovy" scheme="http://www.ct2wj.com/tags/groovy/"/>
    
      <category term="metaprograming" scheme="http://www.ct2wj.com/tags/metaprograming/"/>
    
      <category term="groovy" scheme="http://www.ct2wj.com/categories/groovy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android compile tasks中dex过程源码情景分析]]></title>
    <link href="http://www.ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/"/>
    <id>http://www.ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/</id>
    <published>2015-12-31T09:40:37.000Z</published>
    <updated>2016-01-16T13:33:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p><a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>中我们知道main dex的class可以由maindexlist.txt指定，<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/" target="_blank" rel="external">Android MultiDex机制杂谈</a>中我们分析了google MultiDex机制中Secondary dex的install过程，那么，我们的app在android gradle build过程中，.dex文件是怎么创建的呢？ 再者，Secondary dex中的class是按什么顺序分配到不同dex中的呢？</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="0x01_android_build_system_u6982_u8FF0"><a href="#0x01_android_build_system_u6982_u8FF0" class="headerlink" title="0x01 android build system概述"></a>0x01 android build system概述</h1><p>为了解答上面的两个问题，本文将进一步分析android build system源码。<br><a href="http://developer.android.com/intl/zh-cn/sdk/installing/studio-build.html" target="_blank" rel="external">android build system</a>是google提供的一组用来构建、运行、测试和打包我们app的工具集，包含了<code>aapt</code>、<code>aidl</code>、<code>javac</code>、<code>dex</code>、<code>apkbuilder</code>、<code>Jarsigner</code>、<code>zipalign</code>等工具。在我们构建app时，build进程会去按一定顺序调用上述工具来生成相应文件，而最终的输出将会是一个完整的可安装的.apk文件，构建流程如下：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/build.png" alt=""></p>
<p>构建系统先从product flavors, build types和dependencies中合并资源，如果不同目录下有重名资源，将按以下优先级进行覆盖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &gt; build types &gt; product flavors &gt; main <span class="keyword">source</span> directory</span><br></pre></td></tr></table></figure>
<ol>
<li>aapt编译应用的资源文件（如AndroidManifest.xml），输出R.java文件</li>
<li>aidl把.aidl文件转换为对应的java interface文件</li>
<li>javac编译所有.java文件，输出.class文件</li>
<li>dex工具把上面生成的.class文件转换为.dex文件</li>
<li>apkbuilder把所有没编译的资源（如图片），编译过的资源和dex文件打包输出为.apk文件</li>
<li>在release模式下，用zipalign工具对.apk进行对齐处理，以减少运行时内存占用</li>
</ol>
<p>本文重点对<code>第4步</code>中.class经过dex到.dex过程源码进行分析。</p>
<hr>
<h1 id="0x02_android_compile_tasks_u5206_u6790"><a href="#0x02_android_compile_tasks_u5206_u6790" class="headerlink" title="0x02 android compile tasks分析"></a>0x02 android compile tasks分析</h1><p>为了更好地分析.dex的产生过程，本文设定情景如下：</p>
<blockquote>
<p>构建工具为gradle，采用android plugin <code>&#39;com.android.application&#39;</code>，method数超过65535，需要进行multidex，并且指定了<code>multiDexEnabled = true</code>。</p>
</blockquote>
<p>在shell终端cd到project根目录，输入： </p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">gradle</span> assemble</span><br></pre></td></tr></table></figure>
<p>gradle进程会启动，在dex之前，进程控制流将进入VariantManager. createTasksForVariantData。添加完assemble task依赖后，会去调用taskManager.createTasksForVariantData(tasks, variantData)。由于android plugin为’com.android.application’，这里的taskManager是ApplicationTaskManager。</p>
<p>com/android/build/gradle/internal/VariantManager.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create tasks for the specified variantData.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span><br><span class="line">        <span class="keyword">final</span> TaskFactory tasks,</span><br><span class="line">        <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add dependency of assemble task on assemble build type task.</span></span><br><span class="line">    tasks.named(<span class="string">"assemble"</span>, <span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            BuildTypeData buildTypeData = buildTypes.get(</span><br><span class="line">                            variantData.getVariantConfiguration().getBuildType().getName());</span><br><span class="line">            task.dependsOn(buildTypeData.getAssembleTask());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">        taskManager.createTasksForVariantData(tasks, variantData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ApplicationTaskManager.createTasksForVariantData()会通过ThreadRecorder.get().record()第二个callback参数的类型为Recorder.Block&lt;Void&gt;，在call回调中调用父类TaskManager.createPostCompilationTasks。ThreadRecorder可以记录该任务的在当前线程的执行时间，并且保证task之间是串行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * TaskManager for creating tasks in an Android application project.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTaskManager</span> <span class="keyword">extends</span> <span class="title">TaskManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTasksForVariantData</span><span class="params">(</span><br><span class="line">            @NonNull <span class="keyword">final</span> TaskFactory tasks,</span><br><span class="line">            @NonNull <span class="keyword">final</span> BaseVariantData&lt;? extends BaseVariantOutputData&gt; variantData)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// Add a compile task</span></span><br><span class="line">        ThreadRecorder.get().record(ExecutionType.APP_TASK_MANAGER_CREATE_COMPILE_TASK,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        AndroidTask&lt;JavaCompile&gt; javacTask = createJavacTask(tasks, variantScope);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (variantData.getVariantConfiguration().getUseJack()) &#123;</span><br><span class="line">                            createJackTask(tasks, variantScope);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            setJavaCompilerTask(javacTask, tasks, variantScope);</span><br><span class="line">                            createJarTask(tasks, variantScope);</span><br><span class="line">                            createPostCompilationTasks(tasks, variantScope);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskManager.createPostCompilationTasks方法，这个方法比较长，我们分段来分析。</p>
<p>首先从config得到isMultiDexEnabled，isMultiDexEnabled，isLegacyMultiDexMode，由于已经假设当前为需要MultiDex的场景，因此isMultiDexEnabled为true。若isMinifyEnabled也为true，则说明输入jar包需要进行混淆，本场景先不考虑。</p>
<p>TaskManager.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates the post-compilation tasks for the given Variant.</span><br><span class="line"> *</span><br><span class="line"> * These tasks create the dex file from the .class files, plus optional intermediary steps like</span><br><span class="line"> * proguard and jacoco</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPostCompilationTasks</span><span class="params">(TaskFactory tasks, @NonNull <span class="keyword">final</span> VariantScope variantScope)</span> </span>&#123;</span><br><span class="line">    checkNotNull(variantScope.getJavacTask());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ApkVariantData variantData = (ApkVariantData) variantScope.getVariantData();</span><br><span class="line">    <span class="keyword">final</span> GradleVariantConfiguration config = variantData.getVariantConfiguration();</span><br><span class="line"></span><br><span class="line">    TransformManager transformManager = variantScope.getTransformManager();</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">boolean</span> isMinifyEnabled = config.isMinifyEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> isMultiDexEnabled = config.isMultiDexEnabled();</span><br><span class="line">    <span class="keyword">boolean</span> isLegacyMultiDexMode = config.isLegacyMultiDexMode();</span><br><span class="line"></span><br><span class="line">    AndroidConfig extension = variantScope.getGlobalScope().getExtension();</span><br></pre></td></tr></table></figure>
<p>在支持MultiDex的场景中，先创建manifestKeepListTask，将依赖设置为ManifestProcessorTask，这些android compile task由AndroidTask&lt;TransformTask&gt;类型来描述。</p>
<p>接着创建multiDexClassListTask，依赖manifestKeepListTask。这两个tasks用来输出maindexlist.txt，其中包含了MainDex中必须的class，可参见<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ----- Multi-Dex support</span></span><br><span class="line"></span><br><span class="line">AndroidTask&lt;TransformTask&gt; multiDexClassListTask = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// non Library test are running as native multi-dex</span></span><br><span class="line"><span class="keyword">if</span> (isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode) &#123;</span><br><span class="line">    <span class="keyword">if</span> (AndroidGradleOptions.useNewShrinker(project)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"New shrinker + multidex not supported yet."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="comment">// create a transform to jar the inputs into a single jar.</span></span><br><span class="line">    <span class="keyword">if</span> (!isMinifyEnabled) &#123;</span><br><span class="line">        <span class="comment">// merge the classes only, no need to package the resources since they are</span></span><br><span class="line">        <span class="comment">// not used during the computation.</span></span><br><span class="line">        JarMergingTransform jarMergingTransform = <span class="keyword">new</span> JarMergingTransform(</span><br><span class="line">                TransformManager.SCOPE_FULL_PROJECT);</span><br><span class="line">        transformManager.addTransform(tasks, variantScope, jarMergingTransform);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----------</span></span><br><span class="line">    <span class="comment">// Create a task to collect the list of manifest entry points which are</span></span><br><span class="line">    <span class="comment">// needed in the primary dex</span></span><br><span class="line">    AndroidTask&lt;CreateManifestKeepList&gt; manifestKeepListTask = androidTasks.create(tasks,</span><br><span class="line">            <span class="keyword">new</span> CreateManifestKeepList.ConfigAction(variantScope));</span><br><span class="line">    manifestKeepListTask.dependsOn(tasks,</span><br><span class="line">            variantData.getOutputs().get(<span class="number">0</span>).getScope().getManifestProcessorTask());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    <span class="comment">// create the transform that's going to take the code and the proguard keep list</span></span><br><span class="line">    <span class="comment">// from above and compute the main class list.</span></span><br><span class="line">    MultiDexTransform multiDexTransform = <span class="keyword">new</span> MultiDexTransform(</span><br><span class="line">            variantScope.getManifestKeepListFile(),</span><br><span class="line">            variantScope,</span><br><span class="line">            <span class="keyword">null</span>);</span><br><span class="line">    multiDexClassListTask = transformManager.addTransform(</span><br><span class="line">            tasks, variantScope, multiDexTransform);</span><br><span class="line">    multiDexClassListTask.dependsOn(tasks, manifestKeepListTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后创建dexTask，这个用来把.class文件转为.dex的task，它依赖multiDexClassListTask。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// create dex transform</span></span><br><span class="line">    DexTransform dexTransform = <span class="keyword">new</span> DexTransform(</span><br><span class="line">            extension.getDexOptions(),</span><br><span class="line">            config.getBuildType().isDebuggable(),</span><br><span class="line">            isMultiDexEnabled,</span><br><span class="line">            isMultiDexEnabled &amp;&amp; isLegacyMultiDexMode ? variantScope.getMainDexListFile() : <span class="keyword">null</span>,</span><br><span class="line">            variantScope.getPreDexOutputDir(),</span><br><span class="line">            variantScope.getGlobalScope().getAndroidBuilder(),</span><br><span class="line">            getLogger());</span><br><span class="line">    AndroidTask&lt;TransformTask&gt; dexTask = transformManager.addTransform(</span><br><span class="line">            tasks, variantScope, dexTransform);</span><br><span class="line">    <span class="comment">// need to manually make dex task depend on MultiDexTransform since there's no stream</span></span><br><span class="line">    <span class="comment">// consumption making this automatic</span></span><br><span class="line">    dexTask.optionalDependsOn(tasks, multiDexClassListTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task执行时，gradle引擎会去调用含有@TaskAction注解的方法，TransformTask类拥有Transfrom类型字段，其transform方法被标记为@TaskAction。同样通过ThreadRecorder.get().record中回调call()，执行transform.transform()</p>
<p>TransformTask.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * A task running a transform.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@ParallelizableTask</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformTask</span> <span class="keyword">extends</span> <span class="title">StreamBasedTask</span> <span class="keyword">implements</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transform transform;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">final</span> IncrementalTaskInputs incrementalTaskInputs)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line">		 ...</span><br><span class="line">        ThreadRecorder.get().record(ExecutionType.TASK_TRANSFORM,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Block&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        transform.transform(</span><br><span class="line">                                TransformTask.<span class="keyword">this</span>,</span><br><span class="line">                                consumedInputs.getValue(),</span><br><span class="line">                                referencedInputs.getValue(),</span><br><span class="line">                                outputStream != <span class="keyword">null</span> ? outputStream.asOutput() : <span class="keyword">null</span>,</span><br><span class="line">                                isIncremental.getValue());</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"project"</span>, getProject().getName()),</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"transform"</span>, transform.getName()),</span><br><span class="line">                <span class="keyword">new</span> Recorder.Property(<span class="string">"incremental"</span>, Boolean.toString(transform.isIncremental())));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述android compile tasks关系可以用下图描述：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/multi-dex-task.jpg" alt=""></p>
<p>从gradle task角度上看，这些task都属于TransformTask（继承至DefaultTask），它们区别仅在于transform字段。DexTask是本文主要关心的task，下面分析这个task执行过程中都做了什么。</p>
<hr>
<h1 id="0x03_DexTask_u6267_u884C_u8FC7_u7A0B_u5206_u6790"><a href="#0x03_DexTask_u6267_u884C_u8FC7_u7A0B_u5206_u6790" class="headerlink" title="0x03 DexTask执行过程分析"></a>0x03 DexTask执行过程分析</h1><p>android build system中dex过程发生在DexTask，DexTask关联的Transform是DexTransform。</p>
<p>当DexTransform.transfrom方法被调用时，会先创建并初始化main目录作为输出dex的目录，然后调用androidBuilder.convertByteCode方法进行.class到.dex的转换，此时jarInputs为classes.jar，directoryInputs长度为空，传递的boolean类型的multiDex参数来自build.gralde文件中在<code>defaultConfig</code>对<code>multiDexEnabled = true</code>的设置。</p>
<p>DexTransform.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(</span><br><span class="line">        @NonNull Context context,</span><br><span class="line">        @NonNull Collection&lt;TransformInput&gt; inputs,</span><br><span class="line">        @NonNull Collection&lt;TransformInput&gt; referencedInputs,</span><br><span class="line">        @Nullable TransformOutputProvider outputProvider,</span><br><span class="line">        <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> TransformException, IOException, InterruptedException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// Gather a full list of all inputs.</span></span><br><span class="line">    List&lt;JarInput&gt; jarInputs = Lists.newArrayList();</span><br><span class="line">    List&lt;DirectoryInput&gt; directoryInputs = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (TransformInput input : inputs) &#123;</span><br><span class="line">        jarInputs.addAll(input.getJarInputs());</span><br><span class="line">        directoryInputs.addAll(input.getDirectoryInputs());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// if only one scope or no per-scope dexing, just do a single pass that</span></span><br><span class="line">        <span class="comment">// runs dx on everything.</span></span><br><span class="line">        <span class="keyword">if</span> ((jarInputs.size() + directoryInputs.size()) == <span class="number">1</span> || !dexOptions.getPreDexLibraries()) &#123;</span><br><span class="line">            File outputDir = outputProvider.getContentLocation(<span class="string">"main"</span>,</span><br><span class="line">                    getOutputTypes(), getScopes(),</span><br><span class="line">                    Format.DIRECTORY);</span><br><span class="line">            FileUtils.mkdirs(outputDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first delete the output folder where the final dex file(s) will be.</span></span><br><span class="line">            FileUtils.emptyFolder(outputDir);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// gather the inputs. This mode is always non incremental, so just</span></span><br><span class="line">            <span class="comment">// gather the top level folders/jars</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;File&gt; inputFiles = Lists.newArrayList();</span><br><span class="line">            <span class="keyword">for</span> (JarInput jarInput : jarInputs) &#123;</span><br><span class="line">                inputFiles.add(jarInput.getFile());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DirectoryInput directoryInput : directoryInputs) &#123;</span><br><span class="line">                inputFiles.add(directoryInput.getFile());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            androidBuilder.convertByteCode(</span><br><span class="line">                    inputFiles,</span><br><span class="line">                    outputDir,</span><br><span class="line">                    multiDex,</span><br><span class="line">                    mainDexListFile,</span><br><span class="line">                    dexOptions,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">true</span>,</span><br><span class="line">                    <span class="keyword">new</span> LoggedProcessOutputHandler(logger));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>为了把输入的.class转换为.dex，AndroidBuilder.convertByteCode会另起进程去做dex，实际上是在新进程中exec dex工具，接下来我们进入dex源码，看看到底发生了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertByteCode</span><span class="params">(</span><br><span class="line">         @NonNull Collection&lt;File&gt; inputs,</span><br><span class="line">         @NonNull File outDexFolder,</span><br><span class="line">                  <span class="keyword">boolean</span> multidex,</span><br><span class="line">         @Nullable File mainDexList,</span><br><span class="line">         @NonNull DexOptions dexOptions,</span><br><span class="line">         @Nullable List&lt;String&gt; additionalParameters,</span><br><span class="line">         <span class="keyword">boolean</span> incremental,</span><br><span class="line">         <span class="keyword">boolean</span> optimize,</span><br><span class="line">         @NonNull ProcessOutputHandler processOutputHandler)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, InterruptedException, ProcessException </span>&#123;</span><br><span class="line">...</span><br><span class="line">     BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">     DexProcessBuilder builder = <span class="keyword">new</span> DexProcessBuilder(outDexFolder);</span><br><span class="line"></span><br><span class="line">     builder.setVerbose(mVerboseExec)</span><br><span class="line">             .setIncremental(incremental)</span><br><span class="line">             .setNoOptimize(!optimize)</span><br><span class="line">             .setMultiDex(multidex)</span><br><span class="line">             .setMainDexList(mainDexList)</span><br><span class="line">             .addInputs(verifiedInputs.build());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (additionalParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">         builder.additionalParameters(additionalParameters);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     JavaProcessInfo javaProcessInfo = builder.build(buildToolInfo, dexOptions);</span><br><span class="line"></span><br><span class="line">     ProcessResult result = mJavaProcessExecutor.execute(javaProcessInfo, processOutputHandler);</span><br><span class="line">     result.rethrowFailure().assertNormalExitValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x04_dex_u8FC7_u7A0B_u5206_u6790"><a href="#0x04_dex_u8FC7_u7A0B_u5206_u6790" class="headerlink" title="0x04 dex过程分析"></a>0x04 dex过程分析</h1><p>android 5.0中dex工具源码路径是dalvik/dx/src/com/android/dx，入口类是com.android.dx.command.Main，当解析到参数–dex时，转入com.android.dx.command.dexer.Main.main()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">             <span class="keyword">if</span> (arg.equals(<span class="string">"--dex"</span>)) &#123;</span><br><span class="line">                 com.android.dx.command.dexer.Main.main(without(args, i));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">"--dump"</span>)) &#123;</span><br><span class="line">                 com.android.dx.command.dump.Main.main(without(args, i));</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>main会调用com.android.dx.command.dexer.Main.run()，此时args.multiDex为true，直接进入runMultiDex</p>
<p>com.android.dx.command.dexer.Main.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(Arguments arguments)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.multiDex) &#123;</span><br><span class="line">            <span class="keyword">return</span> runMultiDex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> runMonoDex();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeOutput(humanOutRaw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runMultiDex会调用processAllFiles，第一行代码调用createDexFile()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processAllFiles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     createDexFile();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>createDexFile先检查outputDex(: DexFile)字段是否为空，不为空则调用writeDex()把该dex的byte[]添加到dexOutputArrays(: List&lt;byte[]&gt;)。</p>
<p>writeDex()具体是通过outputDex.toDex(humanOutWriter, args.verboseDump)得到dex的byte[]。java中数组的下标是int类型，长度为32bits，因此一个dex文件最大理论是4G，但实际由于method, field数等限制，正常最大也就10M左右。</p>
<p>然后还会为outputDex字段新建一个DexFile对象，表示当前dex文件已经处理完毕，可以开始处理新的dex文件了。这里假设进程第一次执行createDexFile，因此outputDex为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createDexFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputDex != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dexOutputArrays.add(writeDex());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outputDex = <span class="keyword">new</span> DexFile(args.dexOptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.dumpWidth != <span class="number">0</span>) &#123;</span><br><span class="line">        outputDex.setDumpWidth(args.dumpWidth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后processAllFiles会根据args中numThreads来决定是否需要创建线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.numThreads &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    threadPool = Executors.newFixedThreadPool(args.numThreads);</span><br><span class="line">    parallelProcessorFutures = <span class="keyword">new</span> ArrayList&lt;Future&lt;Void&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来判断args.mainDexListFile，不为空说明指定了maindexlist.txt文件，这里假设不为空，filesNames数组是{‘path/way/to/classes.jar’}，长度为1。方法在for循环中调用processOne()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   anyFilesProcessed = <span class="keyword">false</span>;</span><br><span class="line">   String[] fileNames = args.fileNames;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (args.mainDexListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// with --main-dex-list</span></span><br><span class="line">           FileNameFilter mainPassFilter = args.strictNameCheck ? <span class="keyword">new</span> MainDexListFilter() :</span><br><span class="line">               <span class="keyword">new</span> BestEffortMainDexListFilter();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// forced in main dex</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">               processOne(fileNames[i], mainPassFilter);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>processOne调用ClassPathOpener.process处理输入的classes.jar。ClassPathOpener会遍历classes.jar中的每个ZipEntry，读出byte[]，对每个ZipEntry在回调processFileBytes中调用Main.processFileBytes方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Processes one pathname element.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> pathname &#123;<span class="doctag">@code</span> non-null;&#125; the pathname to process. May</span><br><span class="line"> * be the path of a class file, a jar file, or a directory</span><br><span class="line"> * containing class files.</span><br><span class="line"> * <span class="doctag">@param</span> filter &#123;<span class="doctag">@code</span> non-null;&#125; A filter for excluding files.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processOne</span><span class="params">(String pathname, FileNameFilter filter)</span> </span>&#123;</span><br><span class="line">    ClassPathOpener opener;</span><br><span class="line"></span><br><span class="line">    opener = <span class="keyword">new</span> ClassPathOpener(pathname, <span class="keyword">false</span>, filter,</span><br><span class="line">            <span class="keyword">new</span> ClassPathOpener.Consumer() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Main.processFileBytes(name, lastModified, bytes);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.numThreads &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        parallelProcessorFutures.add(threadPool.submit(<span class="keyword">new</span> ParallelProcessor(opener)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (opener.process()) &#123;</span><br><span class="line">            anyFilesProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main.processFileBytes把输入的bytes分为三类：</p>
<ul>
<li>.class文件</li>
<li>.dex文件</li>
<li>资源文件</li>
</ul>
<p>如果输入是.dex或资源文件，则把bytes分别写入libraryDexBuffers字段或outputResources字段，此时输入name(: String)为.class。当发现是class，则进一步调用processClass处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * Processes one file, which may be either a class or a resource.</span><br><span class="line">  *</span><br><span class="line">  * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file</span><br><span class="line">  * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">  * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processFileBytes</span><span class="params">(String name, <span class="keyword">long</span> lastModified, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> isClass = name.endsWith(<span class="string">".class"</span>);</span><br><span class="line">     <span class="keyword">boolean</span> isClassesDex = name.equals(DexFormat.DEX_IN_JAR_NAME);</span><br><span class="line">     <span class="keyword">boolean</span> keepResources = (outputResources != <span class="keyword">null</span>);</span><br><span class="line">... </span><br><span class="line">     String fixedName = fixPath(name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (isClass) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (keepResources &amp;&amp; args.keepClassesInJar) &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (outputResources) &#123;</span><br><span class="line">                 outputResources.put(fixedName, bytes);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (lastModified &lt; minimumFileAge) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> processClass(fixedName, bytes);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isClassesDex) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (libraryDexBuffers) &#123;</span><br><span class="line">             libraryDexBuffers.add(bytes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (outputResources) &#123;</span><br><span class="line">             outputResources.put(fixedName, bytes);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>processClass方法主要做了以下几件事：</p>
<ol>
<li>为传入的class创建DirectClassFile对象，对应.class字节码文件</li>
<li>得到已经生成的dex的numMethodIds，numFieldIds</li>
<li>得到新Class的constantPoolSize，计算maxMethodIdsInDex = numMethodIds + constantPoolSize + 新Class的方法数 + 2个预留method， 计算maxFieldIdsInDex = numFieldIds + constantPoolSize + 新Class的字段数 + 9个预留field</li>
<li>一旦发现maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex 或者 maxFieldIdsInDex &gt; args.maxNumber OfIdxPerDex，说明当前dex已经满了，调用createDexFile创建新dex来容纳该Class</li>
<li>否则，通过CfTranslator.translate方法将输入的DirectClassFile对象，得到ClassDefItem，添加到outputDex(: DexFile)</li>
</ol>
<p>由此可以看出：</p>
<blockquote>
<p>secondray dex中的class是根据classes.jar中ZipEntry的遍历顺序添加的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">  * Processes one classfile.</span><br><span class="line">  *</span><br><span class="line">  * <span class="doctag">@param</span> name &#123;<span class="doctag">@code</span> non-null;&#125; name of the file, clipped such that it</span><br><span class="line">  * &lt;i&gt;should&lt;/i&gt; correspond to the name of the class it contains</span><br><span class="line">  * <span class="doctag">@param</span> bytes &#123;<span class="doctag">@code</span> non-null;&#125; contents of the file</span><br><span class="line">  * <span class="doctag">@return</span> whether processing was successful</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processClass</span><span class="params">(String name, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (! args.coreLibrary) &#123;</span><br><span class="line">         checkClassName(name);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     DirectClassFile cf =</span><br><span class="line">         <span class="keyword">new</span> DirectClassFile(bytes, name, args.cfOptions.strictNameCheck);</span><br><span class="line"></span><br><span class="line">     cf.setAttributeFactory(StdAttributeFactory.THE_ONE);</span><br><span class="line">     cf.getMagic();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> numMethodIds = outputDex.getMethodIds().items().size();</span><br><span class="line">     <span class="keyword">int</span> numFieldIds = outputDex.getFieldIds().items().size();</span><br><span class="line">     <span class="keyword">int</span> constantPoolSize = cf.getConstantPool().size();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> maxMethodIdsInDex = numMethodIds + constantPoolSize + cf.getMethods().size() +</span><br><span class="line">             MAX_METHOD_ADDED_DURING_DEX_CREATION;</span><br><span class="line">     <span class="keyword">int</span> maxFieldIdsInDex = numFieldIds + constantPoolSize + cf.getFields().size() +</span><br><span class="line">             MAX_FIELD_ADDED_DURING_DEX_CREATION;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (args.multiDex</span><br><span class="line">         <span class="comment">// Never switch to the next dex if current dex is already empty</span></span><br><span class="line">         &amp;&amp; (outputDex.getClassDefs().items().size() &gt; <span class="number">0</span>)</span><br><span class="line">         &amp;&amp; ((maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex) ||</span><br><span class="line">             (maxFieldIdsInDex &gt; args.maxNumberOfIdxPerDex))) &#123;</span><br><span class="line">         DexFile completeDex = outputDex;</span><br><span class="line">         createDexFile();</span><br><span class="line">         <span class="keyword">assert</span>  (completeDex.getMethodIds().items().size() &lt;= numMethodIds +</span><br><span class="line">                 MAX_METHOD_ADDED_DURING_DEX_CREATION) &amp;&amp;</span><br><span class="line">                 (completeDex.getFieldIds().items().size() &lt;= numFieldIds +</span><br><span class="line">                 MAX_FIELD_ADDED_DURING_DEX_CREATION);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         ClassDefItem clazz =</span><br><span class="line">             CfTranslator.translate(cf, bytes, args.cfOptions, args.dexOptions, outputDex);</span><br><span class="line">         <span class="keyword">synchronized</span> (outputDex) &#123;</span><br><span class="line">             outputDex.add(clazz);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (ParseException ex) &#123;</span><br><span class="line">         DxConsole.err.println(<span class="string">"\ntrouble processing:"</span>);</span><br><span class="line">         <span class="keyword">if</span> (args.debug) &#123;</span><br><span class="line">             ex.printStackTrace(DxConsole.err);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ex.printContext(DxConsole.err);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     errors.incrementAndGet();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>再回到processAllFiles，前面假设指定了maindexlist，如果minialMainDex也为true的话，会立即创建新的DexFile，保证这个main dex中只包含maindexlist里的类，如何指定可以参考<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道 0x05</a>。前面没有过滤掉的class都会放入到secondary dex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dexOutputArrays.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">"Too many classes in "</span> + Arguments.MAIN_DEX_LIST_OPTION</span><br><span class="line">                    + <span class="string">", main dex capacity exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.minimalMainDex) &#123;</span><br><span class="line">            <span class="comment">// start second pass directly in a secondary dex file.</span></span><br><span class="line">            createDexFile();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remaining files</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">            processOne(fileNames[i], <span class="keyword">new</span> NotFilter(mainPassFilter));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// without --main-dex-list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">            processOne(fileNames[i], ClassPathOpener.acceptAll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (StopProcessing ex) &#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Ignore it and just let the error reporting do</span><br><span class="line">     * their things.</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在runMultiDex的最后，dex文件将以classes(..N).dex的形式输出在由args.outName指定的目录之下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runMultiDex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.outName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File outDir = <span class="keyword">new</span> File(args.outName);</span><br><span class="line">            <span class="keyword">assert</span> outDir.isDirectory();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dexOutputArrays.size(); i++) &#123;</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(outDir, getDexFileName(i)));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    out.write(dexOutputArrays.get(i));</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    closeOutput(out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x05__u7ED3_u8BBA"><a href="#0x05__u7ED3_u8BBA" class="headerlink" title="0x05 结论"></a>0x05 结论</h1><p>通过对android build system中android plugin tasks和dx工具源码的分析，我们可以得出如下结论：</p>
<ul>
<li><p>.dex文件本质上是.class文件经过com.android.dx.dex.file.DexFile.toDex方法转换得到</p>
</li>
<li><p>Secondary dex是在指定了<code>multiDexEnabled = true且MainDex满足65535限制</code>，或者<code>指定multiDexEnabled = true和minimalMainDex = true</code>的情况下，才会创建的dex，其包含的class是根据classes.jar中ZipEntry的遍历顺序添加的。</p>
</li>
</ul>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/" target="_blank" rel="external">http://ct2wj.com/2015/12/31/dex-source-analysis-in-android-compile-tasks/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p><a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/">MultiDex中出现的main dex capacity exceeded解决之道</a>中我们知道main dex的class可以由maindexlist.txt指定，<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/">Android MultiDex机制杂谈</a>中我们分析了google MultiDex机制中Secondary dex的install过程，那么，我们的app在android gradle build过程中，.dex文件是怎么创建的呢？ 再者，Secondary dex中的class是按什么顺序分配到不同dex中的呢？</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="android compile tasks" scheme="http://www.ct2wj.com/tags/android-compile-tasks/"/>
    
      <category term="build system" scheme="http://www.ct2wj.com/tags/build-system/"/>
    
      <category term="dex" scheme="http://www.ct2wj.com/tags/dex/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android MultiDex机制杂谈]]></title>
    <link href="http://www.ct2wj.com/2015/12/24/android-multidex-source-code-analysis/"/>
    <id>http://www.ct2wj.com/2015/12/24/android-multidex-source-code-analysis/</id>
    <published>2015-12-24T03:53:13.000Z</published>
    <updated>2016-01-16T13:29:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex"><a href="#0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex" class="headerlink" title="0x00 为什么需要MultiDex"></a>0x00 为什么需要MultiDex</h1><p>如果你是一名android开发者，随着app功能复杂度的增加，代码量的增多和库的不断引入，你迟早会在5.0以下的某款设备上遇到：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conversion <span class="keyword">to</span> Dalvik format failed:</span><br><span class="line">Unable <span class="keyword">to</span> execute dex: <span class="function"><span class="keyword">method</span> <span class="title">ID</span> <span class="title">not</span> <span class="title">in</span> [0, 0<span class="title">xffff</span>]:</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trouble writing outpu<span class="variable">t:</span></span><br><span class="line">Too many field reference<span class="variable">s:</span> <span class="number">131000</span>; <span class="built_in">max</span> <span class="keyword">is</span> <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这说明你的app的main dex方法数已经超过<code>65535</code>，如果打算继续兼容5.0以下手机，你可以采用google提供的<a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html" target="_blank" rel="external">MultiDex方案</a>，但main dex方法数为什么不能超过65535呢？<br><a id="more"></a></p>
<p>其实在Dalvik的<a href="http://source.android.com/devices/tech/dalvik/dalvik-bytecode.html" target="_blank" rel="external">invoke-kind指令集</a>中，method reference index只留了16bits，最多能调用65535个方法。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke-kind <span class="comment">&#123;vC, vD, vE, vF, vG&#125;</span>, meth@BBBB</span><br><span class="line"></span><br><span class="line">B: <span class="function"><span class="keyword">method</span> <span class="title">reference</span> <span class="title">index</span> <span class="params">(16 bits)</span></span></span><br></pre></td></tr></table></figure>
<p>所以在生成dex文件的过程中，当方法数超过65535就会报错。我们可以在dx工具源码中找到一些线索：</p>
<p>dalvik/dx/src/com/android/dx/merge/IndexMap.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Maps the index offsets from one dex file to those in another. For example, if</span><br><span class="line"> * you have string #5 in the old dex file, its position in the new dex file is</span><br><span class="line"> * &#123;<span class="doctag">@code</span> strings[5]&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dex target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span>[] stringIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] typeIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] protoIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] fieldIds;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span>[] methodIds;</span><br></pre></td></tr></table></figure>
<p>可以看到，methodIds，typeIds，protoIds，fieldIds都是short[]类型，对于每个具体的method来说都是限制在16bits。google dalvik开发者在这上面挖了个坑，MultiDex就是来填坑的。</p>
<hr>
<h1 id="0x01__u4F7F_u7528MultiDex"><a href="#0x01__u4F7F_u7528MultiDex" class="headerlink" title="0x01 使用MultiDex"></a>0x01 使用MultiDex</h1><p>MultiDex出现在google官方提供的support包里面，使用的时候需要在build.gradle中加上依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'com.android.support:multidex:1.0.0'</span></span><br></pre></td></tr></table></figure>
<p>同时让app的Application继承MultiDexApplication</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDexApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiDexApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        MultiDex.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也别忘了在build.gradle中修改：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiDexEnabled <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x02_MultiDex-install_u8FC7_u7A0B"><a href="#0x02_MultiDex-install_u8FC7_u7A0B" class="headerlink" title="0x02 MultiDex.install过程"></a>0x02 MultiDex.install过程</h1><p>先从MultiDex.install开始分析，传入的context是MultiDexApplication，loader是dalvik.system.PathClassLoader，运行时会先去app的dexDir /data/data/pkgname/code_cache/secondary-dexes下找secondary dex(除了main dex，其他都叫secondary dex，一个apk中可能存在多个secondary dex)，找到后先校验zip格式，没问题就直接installSecondaryDexes，否则会去强制从apk中重新extract secondary dex。</p>
<p>MultiDex.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">     ClassLoader loader;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         loader = context.getClassLoader();</span><br><span class="line">         ...</span><br><span class="line">         File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line">         List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                <span class="comment">// Try again, but this time force a reload of the zip file.</span></span><br><span class="line">                files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Second time didn't work, give up</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>MultiDexExtractor.load方法中，sourceApk指向的是/data/app/pkgname.apk，然后通过getZipCrc获取apk的CRC校验码，去和最后一次CRC校验码对比，若一致或者不是forceReload，那么直接loadExistingExtractions，loadExistingExtractions直接为/data/data/pkgname/code_cache/secondary-dexes/下已经存在的.dex创建File对象；如果不一致说明apk已经被修改了，dex需要重新从apk中抽取，此时执行performExtractions。</p>
<p>MultiDexExtractor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span><br><span class="line">        <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"MultiDexExtractor.load("</span> + applicationInfo.sourceDir + <span class="string">", "</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">final</span> File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currentCrc = getZipCrc(sourceApk);</span><br><span class="line"></span><br><span class="line">    List&lt;File&gt; files;</span><br><span class="line">    <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to reload existing extracted secondary dex files,"</span></span><br><span class="line">                    + <span class="string">" falling back to fresh extraction"</span>, ioe);</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">        files = performExtractions(sourceApk, dexDir);</span><br><span class="line">        putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, <span class="string">"load found "</span> + files.size() + <span class="string">" secondary dex files"</span>);</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performExtractions中真正抽取在extract方法中，输入参数分别是：</p>
<ul>
<li>apk(ZipFile)    指向/data/app/pkgname.apk</li>
<li>dexFile(ZipEntry)    指向classes2.dex</li>
<li>extractTo(File)    指向/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes2.zip</li>
<li>extractedFilePrefix(String)    pkgname.apk.classes</li>
</ul>
<p>extract把dexFile写入到extractTo指向的一个entry，其中InputStream读的是apk中的classes2.apk，ZipOutputStream指向的是一个tmpFile，具体步骤为：</p>
<ol>
<li>在/data/data/pkgname/code_cache/secondary-dexes/创建pkgname.apk.classes12345.zip的tmpFile；</li>
<li>对步骤1的tmpFile建立ZipOutputStream；</li>
<li>创建一个指向classes.dex的ZipEntry对象；</li>
<li>向tmpFile写入这个entry；</li>
<li>将tmpFile重命名为pkgname.apk.classes2.zip，tmpFile此时还存在；</li>
<li>删除tmpFile；</li>
</ol>
<p>extract的实际效果就是在/data/data/pkgname/code_cache/secondary-dexes下创建了：</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes2.zip</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classes3.zip</p>
<p>…</p>
<p>/data/data/pkgname/code_cache/secondary-dexes/pkgname.apk.classesN.zip</p>
<p>N是MultiDex拆分后dex的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">extract</span><span class="params">(ZipFile apk, ZipEntry dexFile, File extractTo,</span><br><span class="line">        String extractedFilePrefix)</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InputStream in = apk.getInputStream(dexFile);</span><br><span class="line">    ZipOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    File tmp = File.createTempFile(extractedFilePrefix, EXTRACTED_SUFFIX,</span><br><span class="line">            extractTo.getParentFile());</span><br><span class="line">    Log.i(TAG, <span class="string">"Extracting "</span> + tmp.getPath());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        out = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(tmp)));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ZipEntry classesDex = <span class="keyword">new</span> ZipEntry(<span class="string">"classes.dex"</span>);</span><br><span class="line">            <span class="comment">// keep zip entry time since it is the criteria used by Dalvik</span></span><br><span class="line">            classesDex.setTime(dexFile.getTime());</span><br><span class="line">            out.putNextEntry(classesDex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> length = in.read(buffer);</span><br><span class="line">            <span class="keyword">while</span> (length != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">                length = in.read(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            out.closeEntry();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"Renaming to "</span> + extractTo.getPath());</span><br><span class="line">        <span class="keyword">if</span> (!tmp.renameTo(extractTo)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Failed to rename \""</span> + tmp.getAbsolutePath() +</span><br><span class="line">                    <span class="string">"\" to \""</span> + extractTo.getAbsolutePath() + <span class="string">"\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        closeQuietly(in);</span><br><span class="line">        tmp.delete(); <span class="comment">// return status ignored</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到真正的install阶段，在MultiDex中有三个私有嵌套类V19,V14和V4来负责具体的系统版本，分别对应android 4.4以上，4.0以上和4.0以下系统。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span><br><span class="line">        InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以4.4为例，V19.install其实就是对输入additionalClassPathEntries反射调用makeDexElements创建Element[]对象，再去修改dalvik.system.BaseDexClassLoader的pathList字段表示的DexPathList类中的dexElements字段内容，把Element[]对象添加进去，这样以后dalvik.system.PathClassLoader就可以找到在secondary dex中的class了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">            File optimizedDirectory)</span></span><br><span class="line">                    <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">                    NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">/* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span></span><br><span class="line">        Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Field suppressedExceptionsField =</span><br><span class="line">                    findField(loader, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">            IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                    (IOException[]) suppressedExceptionsField.get(loader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dexElementsSuppressedExceptions =</span><br><span class="line">                        suppressedExceptions.toArray(</span><br><span class="line">                                <span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                IOException[] combined =</span><br><span class="line">                        <span class="keyword">new</span> IOException[suppressedExceptions.size() +</span><br><span class="line">                                        dexElementsSuppressedExceptions.length];</span><br><span class="line">                suppressedExceptions.toArray(combined);</span><br><span class="line">                System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined,</span><br><span class="line">                        suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                dexElementsSuppressedExceptions = combined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的是，DexPathList:makeDexElements最终会去做dex2opt，其中optimizedDirectory就是之前的dexDir，优化后的dex文件是pkgname.apk.classes2.dex，然而dex2opt会消耗较多的cpu时间，如果全部放在main线程去处理的话，比较影响用户体验，甚至可能引起ANR。</p>
<p>DexPathList.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x03__u63A2_u660E_u7684_u5751"><a href="#0x03__u63A2_u660E_u7684_u5751" class="headerlink" title="0x03 探明的坑"></a>0x03 探明的坑</h1><ul>
<li><p>坑1 如果secondary dex文件太大，可能导致应用在安装过程中出现ANR，这个在0x02 MultiDex.install的最后也提到过，规避方法以后将继续介绍。</p>
</li>
<li><p>坑2 Dalvik linearAlloc bug (<a href="https://code.google.com/p/android/issues/detail?id=22586" target="_blank" rel="external">Issue 22586</a>)：采用MutilDex方案的app在Android4.0以前的设备上可能会启动失败。</p>
</li>
<li><p>坑N-1 Dalvik linearAlloc limit (<a href="http://b.android.com/78035" target="_blank" rel="external">Issue 78035</a>)：使用MultiDex的app需要申请一个大内存，运行时可能导致程序crash，这个Issue在Android4.0已经修复了, 不过还是有可能在低于Android5.0的设备上出现。</p>
</li>
<li><p>坑N <a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">main dex capacity exceeded</a>，一边愉快地编译apk，一边写着代码，突然出现“main dex capacity exceeded”，build failed了… 这个时候怎么办，一种看似有效的办法是指定dex中的method数，例如：</p>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android.applicationVariants.all &#123;</span><br><span class="line">    variant -&gt;</span><br><span class="line">        dex.doFirst&#123;</span><br><span class="line">            dex-&gt;</span><br><span class="line">            <span class="keyword">if</span> (dex.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">                dex.additionalParameters = []</span><br><span class="line">            &#125;</span><br><span class="line">                dex.additionalParameters += <span class="string">'--set-max-idx-number=55000'</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然并卵，虽然编译没问题了，但是运行时会大概率出现<code>ClassNotFoundException</code>和<code>NoClassDefFoundError</code>导致crash，原因很简单，MultiDex.install之前依赖的所有类必须在main dex中，暴力指定main dex数量，可能导致这些类被划分到了secondary dex，系统的PathClassLoader并不能在main dex中找到全部需要加载的类！好在5.0之后，安装app时ART会对apk中所有的classes(..N).dex预编译输出为一个.oat文件，因此找不到类的情况会彻底解决，但是编译时dex过程中main dex capacity exceeded的问题却仍然存在。</p>
<p>一个解决办法是build时指定maindexlist.txt，具体可以参考本博客的另一篇文章<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">MultiDex中出现的main dex capacity exceeded解决之道</a>。</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/" target="_blank" rel="external">http://ct2wj.com/2015/12/24/android-multidex-source-code-analysis/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex"><a href="#0x00__u4E3A_u4EC0_u4E48_u9700_u8981MultiDex" class="headerlink" title="0x00 为什么需要MultiDex"></a>0x00 为什么需要MultiDex</h1><p>如果你是一名android开发者，随着app功能复杂度的增加，代码量的增多和库的不断引入，你迟早会在5.0以下的某款设备上遇到：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conversion <span class="keyword">to</span> Dalvik format failed:</span><br><span class="line">Unable <span class="keyword">to</span> execute dex: <span class="function"><span class="keyword">method</span> <span class="title">ID</span> <span class="title">not</span> <span class="title">in</span> [0, 0<span class="title">xffff</span>]:</span> <span class="number">65536</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trouble writing outpu<span class="variable">t:</span></span><br><span class="line">Too many field reference<span class="variable">s:</span> <span class="number">131000</span>; <span class="built_in">max</span> <span class="keyword">is</span> <span class="number">65536</span>.</span><br><span class="line">You may <span class="keyword">try</span> using --multi-dex option.</span><br></pre></td></tr></table></figure>
<p>这说明你的app的main dex方法数已经超过<code>65535</code>，如果打算继续兼容5.0以下手机，你可以采用google提供的<a href="https://developer.android.com/intl/zh-cn/tools/building/multidex.html">MultiDex方案</a>，但main dex方法数为什么不能超过65535呢？<br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[This is the beginning of the story]]></title>
    <link href="http://www.ct2wj.com/2015/12/22/This-is-the-beginning-of-the-story/"/>
    <id>http://www.ct2wj.com/2015/12/22/This-is-the-beginning-of-the-story/</id>
    <published>2015-12-22T09:53:44.000Z</published>
    <updated>2015-12-22T10:53:20.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/Moving-Castle.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/Moving-Castle.jpg" alt=""></p>
]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MultiDex中出现的main dex capacity exceeded解决之道]]></title>
    <link href="http://www.ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/"/>
    <id>http://www.ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/</id>
    <published>2015-12-22T03:33:07.000Z</published>
    <updated>2016-01-16T13:27:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>随着业务的日益壮大，在集成构建实践中发现，dalvik上的MultiDex拆包方案频繁出现main dex capacity exceeded导致编译失败，对app的年末上线构成了严峻挑战，本文通过控制maindexlist中class的数量，达到减少MainDex体积，避免exceeded的目的。</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="0x01__u4E3A_u4EC0_u4E48_u4F1Amain_dex_capacity_exceeded"><a href="#0x01__u4E3A_u4EC0_u4E48_u4F1Amain_dex_capacity_exceeded" class="headerlink" title="0x01 为什么会main dex capacity exceeded"></a>0x01 为什么会main dex capacity exceeded</h1><p>dx工具执行–dex命令的入口类是com.android.dx.command.dexer.Main，在processAllFiles执行完processOne后如果遇到dexOutputArrays.size() &gt; 0，会抛出DexException，提示”Too many classes in maindexlixt, main dex capacity exceeded”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (args.mainDexListFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// with --main-dex-list</span></span><br><span class="line">	...</span><br><span class="line"><span class="comment">// forced in main dex</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileNames.length; i++) &#123;</span><br><span class="line">                processOne(fileNames[i], mainPassFilter);</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="keyword">if</span> (dexOutputArrays.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> DexException(<span class="string">"Too many classes in "</span> + Arguments.MAIN_DEX_LIST_OPTION</span><br><span class="line">                        + <span class="string">", main dex capacity exceeded"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">	...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>processOne会去调用processClass()，发现如果main dex的方法数超65535，会通过createDexFile()创建一个新的Byte[]对象，被放入dexOutputArrays，导致出现上面的excceed问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">processClass</span><span class="params">(String name, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">      <span class="keyword">int</span> numMethodIds = outputDex.getMethodIds().items().size();</span><br><span class="line">      <span class="keyword">int</span> numFieldIds = outputDex.getFieldIds().items().size();</span><br><span class="line">      <span class="keyword">int</span> constantPoolSize = cf.getConstantPool().size();</span><br><span class="line">      <span class="keyword">int</span> maxMethodIdsInDex = numMethodIds + constantPoolSize + cf.getMethods().size() +</span><br><span class="line">              MAX_METHOD_ADDED_DURING_DEX_CREATION;</span><br><span class="line">      <span class="keyword">int</span> maxFieldIdsInDex = numFieldIds + constantPoolSize + cf.getFields().size() +</span><br><span class="line">              MAX_FIELD_ADDED_DURING_DEX_CREATION;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (args.multiDex</span><br><span class="line">          &amp;&amp; (outputDex.getClassDefs().items().size() &gt; <span class="number">0</span>)</span><br><span class="line">          &amp;&amp; ((maxMethodIdsInDex &gt; args.maxNumberOfIdxPerDex) ||</span><br><span class="line">              (maxFieldIdsInDex &gt; args.maxNumberOfIdxPerDex))) &#123;</span><br><span class="line">          DexFile completeDex = outputDex;</span><br><span class="line">          createDexFile();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x02__u600E_u4E48_u907F_u514D"><a href="#0x02__u600E_u4E48_u907F_u514D" class="headerlink" title="0x02 怎么避免"></a>0x02 怎么避免</h1><p>那么问题来了，应该怎么避免出现main dex类中的方法数超65535呢，这里先说结论：<code>关键在控制好maindexlist.txt中类的数量</code></p>
<hr>
<h1 id="0x03_maindexlist-txt_u7684_u751F_u6210"><a href="#0x03_maindexlist-txt_u7684_u751F_u6210" class="headerlink" title="0x03 maindexlist.txt的生成"></a>0x03 maindexlist.txt的生成</h1><p>android gradle tasks中，有一个叫createXXXMainDexClassList的task专门负责创建maindexlist.txt，源码在gradle-core：</p>
<p>CreateMainDexList.groovy</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TaskAction</span></span><br><span class="line"><span class="typename">void</span> output() &#123;</span><br><span class="line">    <span class="keyword">if</span> (getAllClassesJarFile() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"No input file"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// manifest components plus immediate dependencies must be in the main dex.</span></span><br><span class="line">    File _allClassesJarFile = getAllClassesJarFile()</span><br><span class="line">    Set&lt;String&gt; mainDexClasses = callDx(_allClassesJarFile, getComponentsJarFile())</span><br></pre></td></tr></table></figure>
<p>这里的_allClassesJarFile是allclasses.jar，第二个jar是componentClasses.jar，componentClasses.jar很重要，一会还会提到，callDx方法不是去做真正的dx，而是调了AndroidBuilder:createMainDexList()</p>
<p>AndroidBuilder.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">callDx</span><span class="params">(File allClassesJarFile, File jarOfRoots)</span> <span class="keyword">throws</span> ProcessException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> variantScope.getGlobalScope().getAndroidBuilder().createMainDexList(</span><br><span class="line">            allClassesJarFile, jarOfRoots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMainDexList()会用到ClassReferenceListBuilder(5.0之前叫MainDexListBuilder), 它的职责是用来分析类的依赖关系，具体通过JavaProcessExecutor单独开启进程去执行ClassReferenceListBuilder的main方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">createMainDexList</span><span class="params">(</span><br><span class="line">          @NonNull File allClassesJarFile,</span><br><span class="line">          @NonNull File jarOfRoots)</span> <span class="keyword">throws</span> ProcessException </span>&#123;</span><br><span class="line"></span><br><span class="line">      BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">      ProcessInfoBuilder builder = <span class="keyword">new</span> ProcessInfoBuilder();</span><br><span class="line"></span><br><span class="line">      String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX_JAR);</span><br><span class="line">      builder.setClasspath(dx);</span><br><span class="line">      builder.setMain(<span class="string">"com.android.multidex.ClassReferenceListBuilder"</span>);</span><br><span class="line"></span><br><span class="line">      builder.addArgs(jarOfRoots.getAbsolutePath());</span><br><span class="line">      builder.addArgs(allClassesJarFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">      CachedProcessOutputHandler processOutputHandler = <span class="keyword">new</span> CachedProcessOutputHandler();</span><br><span class="line"></span><br><span class="line">      mJavaProcessExecutor.execute(builder.createJavaProcess(), processOutputHandler)</span><br><span class="line">              .rethrowFailure()</span><br><span class="line">              .assertNormalExitValue();</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    ZipFile jarOfRoots;</span><br><span class="line">    jarOfRoots = <span class="keyword">new</span> ZipFile(args[<span class="number">0</span>]);</span><br><span class="line">...</span><br><span class="line">    Path path = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        path = <span class="keyword">new</span> Path(args[<span class="number">1</span>]);</span><br><span class="line">        ClassReferenceListBuilder builder = <span class="keyword">new</span> ClassReferenceListBuilder(path);</span><br><span class="line">        builder.addRoots(jarOfRoots);</span><br><span class="line">        printList(builder.toKeep);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>为了确定ClassReferenceListBuilder.main的两个输入参数，这里用<a href="http://jboss-javassist.github.io/javassist/" target="_blank" rel="external">javassist.jar</a>运行时改写ClassReferenceListBuilder.class文件，主要是在main方法最前面加上System.err.println（java.util.Arrays.toString(args)），目的是把标准错误输出流打印到终端，保险起见，通过PrintWriter同时把参数输出到本地文件log.txt。</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/printArgs.jpg" alt=""></p>
<p>实验过程中发现，gradle build进程的标准错误输出流没打印出来，可能被重定向了，不过本地log.txt记录下了参数信息：</p>
<pre><code>[[省略...]/release/componentClasses.jar, [省略...]/release/classes.jar]
</code></pre><p>可见arg[0]是componentClasses.jar， arg[1]是app完整的classes.jar</p>
<p>ClassReferenceListBuilder的addRoots通过读文件的方式去遍历componentClasses.jar中的每个entry，再调用addDependencies和.class文件的常量池来分析这个类的依赖关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoots</span><span class="params">(ZipFile jarOfRoots)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">...	</span><br><span class="line">      <span class="keyword">for</span> (Enumeration&lt;? extends ZipEntry&gt; entries = jarOfRoots.entries();</span><br><span class="line">              entries.hasMoreElements();) &#123;</span><br><span class="line">          ZipEntry entry = entries.nextElement();</span><br><span class="line">          String name = entry.getName();</span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(CLASS_EXTENSION)) &#123;</span><br><span class="line">              DirectClassFile classFile;</span><br><span class="line">			...</span><br><span class="line">                  classFile = path.getClass(name);</span><br><span class="line">			...</span><br><span class="line">              addDependencies(classFile.getConstantPool());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>addDependencies方法从输入的ConstantPool参数，得到import类，并调用addClassWithHierachy继续分析继承关系（也可以通过javap -verbose先反汇编，再分析匹配”= class”的字符串来获取，具体可以参考本文的<a href="https://github.com/JLLK/ClassDependenceAnalyser" target="_blank" rel="external">依赖分析工具</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDependencies</span><span class="params">(ConstantPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Constant constant : pool.getEntries()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constant <span class="keyword">instanceof</span> CstType) &#123;</span><br><span class="line">            Type type = ((CstType) constant).getClassType();</span><br><span class="line">            String descriptor = type.getDescriptor();</span><br><span class="line">            <span class="keyword">if</span> (descriptor.endsWith(<span class="string">";"</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> lastBrace = descriptor.lastIndexOf(<span class="string">'['</span>);</span><br><span class="line">                <span class="keyword">if</span> (lastBrace &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    addClassWithHierachy(descriptor.substring(<span class="number">1</span>, descriptor.length()-<span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">assert</span> descriptor.length() &gt; lastBrace + <span class="number">3</span></span><br><span class="line">                    &amp;&amp; descriptor.charAt(lastBrace + <span class="number">1</span>) == <span class="string">'L'</span>;</span><br><span class="line">                    addClassWithHierachy(descriptor.substring(lastBrace + <span class="number">2</span>,</span><br><span class="line">                            descriptor.length() - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addClassWithHierachy是通过递归分析父类和其实现接口的继承关系，toKeep包含了将要输出到maindexlist的class，这里主要是去重用的，避免重复添加class。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addClassWithHierachy</span><span class="params">(String classBinaryName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toKeep.contains(classBinaryName)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String fileName = classBinaryName + CLASS_EXTENSION;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        DirectClassFile classFile = path.getClass(fileName);</span><br><span class="line">        toKeep.add(classBinaryName);</span><br><span class="line">        CstType superClass = classFile.getSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            addClassWithHierachy(superClass.getClassType().getClassName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TypeList interfaceList = classFile.getInterfaces();</span><br><span class="line">        <span class="keyword">int</span> interfaceNumber = interfaceList.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaceNumber; i++) &#123;</span><br><span class="line">            addClassWithHierachy(interfaceList.getType(i).getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖关系分析结束后，toKeep输出为maindexlist.txt，这里标准输出被重定向到了maindexlist.txt文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(Set&lt;String&gt; toKeep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String classDescriptor : toKeep) &#123;</span><br><span class="line">        System.out.print(classDescriptor);</span><br><span class="line">        System.out.println(CLASS_EXTENSION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="0x04_componentClasses-jar_u7684_u6765_u6E90"><a href="#0x04_componentClasses-jar_u7684_u6765_u6E90" class="headerlink" title="0x04 componentClasses.jar的来源"></a>0x04 componentClasses.jar的来源</h1><p>经过前面的分析，其实可以看出<code>componentClasses.jar决定了maindexlist</code></p>
<p>而componentClasses.jar是proguardComponentsTask根据manifest_keep.txt从allclasses.jar中抽取生成的，manifest_keep.txt内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">app</span>.<span class="title">XXXXApplication</span> </span>&#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(android.content.Context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">splash</span>.<span class="title">XXXXActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">app</span>.<span class="title">MainActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">login</span>.<span class="title">xxxx</span>.<span class="title">LoginActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">xxxx</span>.<span class="title">sdk</span>.<span class="title">sidebar</span>.<span class="title">account</span>.<span class="title">XXAccountActivity</span> </span>&#123; &lt;init&gt;(); &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么manifest_keep.txt由谁生成的呢？ 在gradle-core中，CreateManifestKeepList类的generateKeepListFromManifest方法会先去解析AndroidManifest.xml文件。这里可以发现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">*</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">backup</span>.<span class="title">BackupAgent</span> &#123;</span></span><br><span class="line">    &lt;init&gt;();</span><br><span class="line">&#125;</span><br><span class="line">-keep public <span class="class"><span class="keyword">class</span> <span class="title">*</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span> &#123;</span></span><br><span class="line">    *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CreateManifestKeepList.groovy</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="annotation">@TaskAction</span></span><br><span class="line">   <span class="typename">void</span> generateKeepListFromManifest() &#123;</span><br><span class="line">       SAXParser parser = SAXParserFactory.newInstance().newSAXParser()</span><br><span class="line"></span><br><span class="line">       Writer out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(getOutputFile()))</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           parser.parse(getManifest(), <span class="keyword">new</span> ManifestHandler(out))</span><br><span class="line">           out.write(</span><br><span class="line"><span class="string">"""-keep public class * extends android.app.backup.BackupAgent &#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">&#125;</span><br><span class="line">-keep public class * extends java.lang.annotation.Annotation &#123;</span><br><span class="line">   *;</span><br><span class="line">&#125;</span><br><span class="line">"""</span>)</span><br></pre></td></tr></table></figure>
<p>getOutputFile拿到的File对象指向的是manifest_keep.txt，私有内部类ManifestHandler的startElement方法，CreateManifestKeepList.KEEP_SPECS[qName]决定哪些类需要放入manifest_keep.txt。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ManifestHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attributes attr)</span> </span>&#123;</span><br><span class="line">        String keepSpec = CreateManifestKeepList.KEEP_SPECS[qName]</span><br><span class="line">        <span class="keyword">if</span> (keepSpec) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> keepIt = <span class="function"><span class="keyword">true</span></span><br><span class="line">            <span class="title">if</span> <span class="params">(CreateManifestKeepList.<span class="keyword">this</span>.filter)</span> </span>&#123;</span><br><span class="line">                Map&lt;String, String&gt; attrMap = [:]</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attr.getLength(); i++) &#123;</span><br><span class="line">                    attrMap[attr.getQName(i)] = attr.getValue(i)</span><br><span class="line">                &#125;</span><br><span class="line">                keepIt = CreateManifestKeepList.<span class="keyword">this</span>.filter(qName, attrMap)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (keepIt) &#123;</span><br><span class="line">                String nameValue = attr.getValue(<span class="string">'android:name'</span>)</span><br><span class="line">                <span class="keyword">if</span> (nameValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.write((String) <span class="string">"-keep class $&#123;nameValue&#125; $keepSpec\n"</span>)</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>用来过滤的KEEP_SPECS：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="type">String</span> <span class="type">DEFAULT_KEEP_SPEC</span> = <span class="string">"&#123; &lt;init&gt;(); &#125;"</span></span><br><span class="line">   <span class="keyword">private</span> static <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; <span class="type">KEEP_SPECS</span> = [</span><br><span class="line">       <span class="symbol">'applicatio</span>n'       : <span class="string">"""&#123;</span><br><span class="line">   &lt;init&gt;();</span><br><span class="line">   void attachBaseContext(android.content.Context);</span><br><span class="line">&#125;"""</span>,</span><br><span class="line">       <span class="symbol">'activit</span>y'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'servic</span>e'           : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'receive</span>r'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'provide</span>r'          : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">       <span class="symbol">'instrumentatio</span>n'   : <span class="type">DEFAULT_KEEP_SPEC</span>,</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
<p>可见，至少AndroidManifest.xml中<code>application</code>,<code>activity</code>,<code>service</code>,<code>receiver</code>,<code>provider</code>,<code>instrumentation</code>这6种标签的类，以及继承至<code>java.lang.annotation.Annotation</code>和<code>android.app.backup.BackupAgent</code>的类会被作为输入条件，用来产生maindexlist.txt。</p>
<hr>
<h1 id="0x05__u89E3_u51B3_u4E4B_u9053"><a href="#0x05__u89E3_u51B3_u4E4B_u9053" class="headerlink" title="0x05 解决之道"></a>0x05 解决之道</h1><p>本文绕过gradle build工具make componentClasses.jar的方式，不纠结于如何控制componentClasses.jar，而是直接指定哪些类需要放进maindexlist，达到减少maindexlist class数量，避免main dex capacity exceeded的出现。</p>
<p>首先从app的com.xxxx.sdk.app.XXXXApplication类出发，分析出MultiDex.install之前的所有必须打进main dex中的类（MultiDex包也需并入分析），输出到maindexlist.txt。<code>正确分析依赖关系非常重要</code>，否则运行时一定出现ClassNotFoundException。XXXXApplication对外依赖越少越好，可以通过java反射和动态加载特性让其仅依赖android.jar和接口类。</p>
<p>另外加载过程中，被加载类的static initializer块里（clinit）使用的类和inner类也会被加载器主动load，需确保在maindexlist.txt中，可以使用本人用scala写的<a href="https://github.com/JLLK/ClassDependenceAnalyser" target="_blank" rel="external">依赖分析工具</a>来进行分析，得到maindexlist.txt。</p>
<p>最后，还需在build.gradle中加上：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">"dex"</span>)</span><br><span class="line">    &#125;.each &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="literal">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// optional</span></span><br><span class="line">    dx.additionalParameters += <span class="string">"--main-dex-list=$projectDir/maindexlist.txt"</span>.toString()</span><br><span class="line">    dx.additionalParameters += <span class="string">"--minimal-main-dex"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终maindexlist.txt中类的数量成功由4000减少到1116，main dex由7M减少到1.3M，du -sh *.dex输出如下：</p>
<p><img src="http://7xpcru.com1.z0.glb.clouddn.com/maindex_output.png?imageView2/2/w/150" alt=""></p>
<p>从此再也不用担心main dex capacity exceeded了^_-</p>
<hr>
<h4 id="u7248_u6743_u58F0_u660E"><a href="#u7248_u6743_u58F0_u660E" class="headerlink" title="版权声明"></a>版权声明</h4><p><img src="http://7xpcru.com1.z0.glb.clouddn.com/cc.png" alt=""></p>
<p><a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a> by <a href="http://ct2wj.com/about" target="_blank" rel="external">CHEN TAO</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0 International License</a>.</p>
<p>由<a href="http://ct2wj.com/about" target="_blank" rel="external">陈涛</a>创作并维护的<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客采用<a href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">创作共用保留署名-非商业-禁止演绎4.0国际许可证</a>。</p>
<p>本文首发于<a href="http://ct2wj.com" target="_blank" rel="external">CT2WJ</a>博客（ <a href="http://ct2wj.com" target="_blank" rel="external">http://ct2wj.com</a> ），版权所有，侵权必究。</p>
<p>本文永久链接：<a href="http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/" target="_blank" rel="external">http://ct2wj.com/2015/12/22/the-way-to-solve-main-dex-capacity-exceeded-in-Android-gradle-build/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00"><a href="#0x00__u524D_u8A00" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><blockquote>
<p>随着业务的日益壮大，在集成构建实践中发现，dalvik上的MultiDex拆包方案频繁出现main dex capacity exceeded导致编译失败，对app的年末上线构成了严峻挑战，本文通过控制maindexlist中class的数量，达到减少MainDex体积，避免exceeded的目的。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.ct2wj.com/tags/Android/"/>
    
      <category term="MainDex" scheme="http://www.ct2wj.com/tags/MainDex/"/>
    
      <category term="MultiDex" scheme="http://www.ct2wj.com/tags/MultiDex/"/>
    
      <category term="build" scheme="http://www.ct2wj.com/tags/build/"/>
    
      <category term="gradle" scheme="http://www.ct2wj.com/tags/gradle/"/>
    
      <category term="Android" scheme="http://www.ct2wj.com/categories/Android/"/>
    
  </entry>
  
</feed>
